<html>
  <head>
    <title>vedit</title>
    <meta charset="utf-8" />
    <style>
      * {
        --theme-text-color: #000000;
        --theme-subtext-color: #111111;
        --theme-disabled-text-color: #00000066;
        --theme-editor-text-color: #000000;
        --theme-editor-bg: #ffffff;
        --theme-nav-bg: #eeeeee;
        --theme-tabs-bg: #ffffff;
        --theme-tab-tip-bg: #dddddd;
        --theme-tab-untitled: #666666;
        --theme-menu-item-bg: #ffffff;
        --theme-main-color: #ffffff;
        --theme-sub-color: #000000;
        --theme-main-hover-color: #ffffff33;
        --theme-sub-hover-color: #00000033;
        --nav-height: 2em;
        --tabs-height: 24px;
        --bottom-label-height: 24px;
        --logo-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNjQgNjQiIHdpZHRoPSI2NHB4IiBoZWlnaHQ9IjY0cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6Yng9Imh0dHBzOi8vYm94eS1zdmcuY29tIj4NCiAgPGRlZnM+DQogICAgPGZpbHRlciBpZD0ib3V0bGluZS1maWx0ZXItMCIgeD0iLTUwMCUiIHk9Ii01MDAlIiB3aWR0aD0iMTAwMCUiIGhlaWdodD0iMTAwMCUiIGJ4OnByZXNldD0ib3V0bGluZSAxIDEgcmdiYSgyNTUsMjU1LDI1NSwxKSI+DQogICAgICA8ZmVNb3JwaG9sb2d5IGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJkaWxhdGVkIiBvcGVyYXRvcj0iZGlsYXRlIiByYWRpdXM9IjEiPjwvZmVNb3JwaG9sb2d5Pg0KICAgICAgPGZlRmxvb2QgZmxvb2QtY29sb3I9InJnYmEoMjU1LDI1NSwyNTUsMSkiIHJlc3VsdD0iZmxvb2QiPjwvZmVGbG9vZD4NCiAgICAgIDxmZUNvbXBvc2l0ZSBpbj0iZmxvb2QiIGluMj0iZGlsYXRlZCIgb3BlcmF0b3I9ImluIiByZXN1bHQ9Im91dGxpbmUiPjwvZmVDb21wb3NpdGU+DQogICAgICA8ZmVNZXJnZT4NCiAgICAgICAgPGZlTWVyZ2VOb2RlIGluPSJvdXRsaW5lIj48L2ZlTWVyZ2VOb2RlPg0KICAgICAgICA8ZmVNZXJnZU5vZGUgaW49IlNvdXJjZUdyYXBoaWMiPjwvZmVNZXJnZU5vZGU+DQogICAgICA8L2ZlTWVyZ2U+DQogICAgPC9maWx0ZXI+DQogIDwvZGVmcz4NCiAgPGNpcmNsZSBzdHlsZT0iZmlsbDogcmdiKDIyMywgMjQxLCAyNTUpOyIgY3g9IjMyIiBjeT0iMzIiIHI9IjMyIj48L2NpcmNsZT4NCiAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC42MTg3MDcsIDAuNjE4NzA3LCAtMC42MTg3MDcsIDAuNjE4NzA3LCAzMi4wMDAzMDEsIC03LjU5Nzg0NikiIHN0eWxlPSJmaWx0ZXI6IHVybCgjb3V0bGluZS1maWx0ZXItMCk7Ij4NCiAgICA8cGF0aCBzdHlsZT0iZmlsbDogcmdiKDkwLCA5MCwgOTApOyIgZD0iTSAyOCAwIEggMzYgQSA4IDggMCAwIDEgNDQgOCBWIDQ4IEggMjAgViA4IEEgOCA4IDAgMCAxIDI4IDAgWiIgYng6c2hhcGU9InJlY3QgMjAgMCAyNCA0OCA4IDggMCAwIDFAZjBjN2UzMTkiIGJ4Om9yaWdpbj0iMC41IDAuNjY2NjY3Ij48L3BhdGg+DQogICAgPHBhdGggZD0iTSAzOC42OSAxOS41NTggTCA1MC42OSAzNS41NTggTCAyNi42OSAzNS41NTggTCAzOC42OSAxOS41NTggWiIgc3R5bGU9ImZpbGw6IHJnYigyNTUsIDIyMSwgMTAyKTsiIHRyYW5zZm9ybT0ibWF0cml4KC0xLCAtMC4wMDAwNTIsIDAuMDAwMDUyLCAtMSwgNzAuNjg4OTM0LCA4My41NjA1NDcpIiBieDpzaGFwZT0idHJpYW5nbGUgMjYuNjkgMTkuNTU4IDI0IDE2IDAuNSAwIDFANjMzOTNjZTgiIGJ4Om9yaWdpbj0iMC41MDAwNjYgMi4wMDAwMzgiPjwvcGF0aD4NCiAgPC9nPg0KPC9zdmc+");
      }
      @media (prefers-color-scheme: dark) {
        * {
          --theme-text-color: #ffffff;
          --theme-subtext-color: #eeeeee;
          --theme-disabled-text-color: #ffffff66;
          --theme-editor-text-color: #ffffff;
          --theme-editor-bg: #000000;
          --theme-nav-bg: #222222;
          --theme-tabs-bg: #333333;
          --theme-tab-tip-bg: #555555;
          --theme-tab-untitled: #dddddd;
          --theme-menu-item-bg: #444444;
          --theme-main-color: #333333;
          --theme-sub-color: #ffffff;
          --theme-main-hover-color: #00000033;
          --theme-sub-hover-color: #ffffff33;
        }
      }
      *:not(input):not(textarea):not(select):not(.preview *) {
        color: var(--theme-text-color);
      }
      body {
        margin: 0;
        width: 100vw;
        height: 100vh;
      }
      nav {
        background-color: var(--theme-nav-bg);
        height: var(--nav-height);
        font-size: calc(var(--nav-height) / 2.25);
        z-index:50
      }
      nav > .menu > .item {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        height: var(--nav-height);
        min-width: 4em;
        padding: calc(var(--nav-height) * 0.1);
        background-color: transparent;
        box-sizing: border-box;
      }
      nav > .menu > .item > div.label {
        display: inline-flex;
        width: 100%;
        height: 100%;
        padding-inline: 0.5em;
        justify-content: center;
        align-items: center;
        color: var(--theme-text-color);
        background-color: transparent;
        border-radius: 0.5em;
      }
      nav > .menu > .item:hover > div.label {
        background-color: var(--theme-sub-hover-color);
      }
      nav > .menu > .item div.drop {
        position: absolute;
        display: none;
        width: max-content;
        min-width: 8em;
        padding: 0.25em;
        border: solid 1px #666666;
        flex-direction: column;
        align-items: center;
        top: 100%;
        left: 0;
        margin: 0;
        background-color: var(--theme-menu-item-bg);
        box-sizing: border-box;
        z-index: 1;
      }
      nav > .menu > .item:hover > div.drop {
        display: inline-flex;
      }
      nav > .menu > .item div.drop > .child {
        display: inline-flex;
        position: relative;
        min-width: max-content;
        width: 100%;
        min-height: 1.75em;
        padding-block: 0.1em;
        justify-content: center;
        align-items: center;
        color: var(--theme-subtext-color);
        box-sizing: border-box;
        white-space: nowrap;
      }
      nav > .menu > .item div.drop > .child + .child {
        border-top: solid 1px #000000;
        height: calc(1.75em + 1px);
      }
      nav > .menu > .item div.drop > .child > button {
        display: inline-flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        height: 1.75em;
        border: none;
        border-radius: 0.25em;
        color: var(--theme-subtext-color);
        background-color: transparent;
      }
      nav > .menu > .item div.drop > .child > button > .title {
      }
      nav > .menu > .item div.drop > .child > button > .sub {
        font-size: 0.9em;
        color: var(--theme-sub-hover-color);
        margin-left: 1em;
      }
      nav > .menu > .item div.drop > .child > button[disabled] {
        color: var(--theme-disabled-text-color);
      }
      nav > .menu > .item div.drop > .child > button:not([disabled]):hover {
        background-color: var(--theme-sub-hover-color);
      }
      nav > .menu > .item div.drop .child > div.drop {
        top: 0;
        left: 100%;
      }
      nav > .menu > .item div.drop .child:hover > div.drop {
        display: inline-flex;
      }
      pop-up {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        min-width: 8em;
        min-height: 1.5em;
        width: max-content;
        border: solid 1px var(--theme-sub-color);
        border-radius: 2px;
        background: var(--theme-nav-bg);
        flex-direction: column;
        overflow: hidden;
        z-index: 100;
      }
      pop-up[active] {
        display: inline-flex;
      }
      pop-up > div.header {
        display: inline-flex;
        width: 100%;
        height: 1.5em;
        padding: 0.1em;
        justify-content: flex-end;
        box-sizing: border-box;
      }
      pop-up > div.header > button {
        display: inline-block;
        height: 100%;
        aspect-ratio: 1;
        padding: 0;
        margin: 0;
        border: none;
        border-radius: 40%;
        background: transparent;
      }
      pop-up > div.header > button:hover {
        background: var(--theme-sub-hover-color);
      }
      pop-up > div.header > button > span.image {
        display: inline-block;
        height: 100%;
        aspect-ratio: 1;
        padding: 20%;
        margin: 0;
        border: none;
        background-color: var(--theme-text-color);
        -webkit-mask-size: contain;
        -webkit-mask-origin: content-box;
        -webkit-mask-repeat: no-repeat;
        box-sizing: border-box;
        transition: 0.2s transform;
      }
      pop-up > div.header > button.close > span.image {
        -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMTYiIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE2cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogIDxkZWZzPjwvZGVmcz4NCiAgPHBvbHlnb24gc3R5bGU9ImZpbGw6IHJnYigyMTYsIDIxNiwgMjE2KTsiIHBvaW50cz0iMCAwIDIgMCA4IDYgMTQgMCAxNiAwIDE2IDIgMTAgOCAxNiAxNCAxNiAxNiAxNCAxNiA4IDEwIDIgMTYgMCAxNiAwIDE0IDYgOCAwIDIiPjwvcG9seWdvbj4NCjwvc3ZnPg==");
      }
      pop-up > div.header > button.minimize > span.image {
        -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMTYiIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE2cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogIDxkZWZzPjwvZGVmcz4NCiAgPHBvbHlnb24gc3R5bGU9ImZpbGw6IHJnYigyMTYsIDIxNiwgMjE2KTsiIHBvaW50cz0iOCAzIDAgMTEgMCAxMyAyIDEzIDggNyAxNCAxMyAxNiAxMyAxNiAxMSI+PC9wb2x5Z29uPg0KPC9zdmc+");
      }
      pop-up[minimized] > div.header > button.minimize > span.image {
        -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMTYiIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE2cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogIDxkZWZzPjwvZGVmcz4NCiAgPHBvbHlnb24gc3R5bGU9ImZpbGw6IHJnYigyMTYsIDIxNiwgMjE2KTsiIHBvaW50cz0iOCAzIDAgMTEgMCAxMyAyIDEzIDggNyAxNCAxMyAxNiAxMyAxNiAxMSI+PC9wb2x5Z29uPg0KPC9zdmc+");
        transform: rotate(180deg);
      }
      pop-up > div.body {
        display: inline-block;
        max-height: 100vh;
        height: calc(100% - 1.5em);
        color: var(--theme-text-color);
        background: var(--theme-menu-item-bg);
        transition: 0.1s max-height;
        overflow: scroll;
      }
      pop-up[minimized] > div.body {
        max-height: 0vh;
      }
      pop-up > div.body div.buttons {
        display: inline-flex;
        width: 100%;
        padding: 0.5em;
        justify-content: space-around;
        box-sizing: border-box;
      }
      pop-up > div.body button, pop-up > div.body input[type="button"], pop-up > div.body input[type="submit"] {
        display: inline-block;
        padding-inline: 1em;
        padding-block: 0.5em;
        border: none;
        border-radius: 0.5em;
      }
      body {
        margin: 0;
        background: var(--theme-main-color)
      }
      .main {
        display: flex;
        flex-direction: column;
        flex-wrap: wrap;
        height: calc(100% - 2rem);
        padding: 0.5rem;
        box-sizing: border-box;
        overflow: hidden;
      }
      .area {
        display: inline-flex;
        width: 100%;
        height: calc(50% - 1em);
        justify-content: space-evenly;
        gap: 0.5rem;
      }
      .main:has(.side-panel:first-child > input.nob:checked, .side-panel:last-child > input.nob:checked) .area {
        width: calc(100% - 20vw);
      }
      .main:has(.side-panel:first-child > input.nob:checked):has(.side-panel:last-child > input.nob:checked) .area {
        width: calc(100% - 40vw);
      }
      .side-panel {
        position: relative;
        width: 20vw;
        height: 100%;
        border: solid 1px white;
        box-sizing: border-box;
        overflow: scroll;
      }
      .side-panel:first-child {
        border-left: none;
        margin-left: -1rem;
      }
      .side-panel:last-child {
        border-right: none;
        margin-right: -1rem;
      }
      .side-panel > input.nob {
        position: absolute;
        top: 50%;
      }
      .side-panel:first-child > input.nob {
        right: 0;
        translate: 100% -50%;
      }
      .side-panel:last-child > input.nob {
        left: 0;
        translate: -100% -50%;
      }
      .side-panel > input.nob:checked {
        translate-x: 0 -50%;
      }
      .preview-box {
        display: block;
        width: 50%;
        height: 100%;
        background: black;
        border: solid 1px #fff;
        box-sizing: border-box;
      }
      .preview {
        position: relative;
        max-width: 100%;
        max-height: 100%;
        aspect-ratio: calc(var(--preview-width) / var(--preview-height));
        background: black;
        margin: auto;
        top: 50%;
        transform: translateY(-50%);
        box-sizing: border-box;
        overflow: hidden;
        transition: width 0.01ms, height 0.01ms;
      }
      .preview > * {
        position: absolute;
        top: 0;
        left: 0;
        translate: calc(0px - 50% * (1 - var(--unit-px))) calc(0px - 50% * (1 - var(--unit-px)));
        scale: var(--unit-px);
        object-fit: fill;
      }
      .preview > .text > p {
        margin: 0;
        white-space: pre;
      }
      .preview > .text > p + p {
        position: absolute;
        top: 0;
        left: 0;
      }
      .detail {
        width: 50%;
        height: 100%;
        border: solid 1px black;
        border-radius: 0.5em;
        overflow: scroll;
      }
      .tooltip {
        height: 2em;
      }
      .tooltip {
        display: flex;
        align-items: stretch;
        align-content: center;
        height: 30px;
        flex-wrap: nowrap;
        flex-direction: row;
        justify-content: flex-start;
      }
      .tooltip > *:is(button, input[type="button"], input[type="radio"]) {
          margin: 2px;
      }
      .tooltip > *:is(button, input[type="button"], input[type="radio"]) {
        display: flex;
        position: relative;
        border: none;
        justify-content: center;
        align-items: center;
        padding: 0.9em 6px;
        height: 12px;
        background-color: transparent;
        color: #fff;
        text-decoration: none;
        transition: 0.05s;
        flex-direction: row;
        font-weight: bold;
      }
      .tooltip > *:is(button, input[type="button"], input[type="radio"]):hover {
          background-color: #ffffff22;
      }

      .tooltip > *:is(button, input[type="button"], input[type="radio"]):active::before {
        height: 5px;
        transition: height 0.05s, opacity 0.1s;
      }
      .tooltip > *:is(button, input[type="button"], input[type="radio"]):hover::before {
        width: 100%;
        left: 0;
        opacity: 1;
        bottom: 0;
      }
      .tooltip > *:is(button, input[type="button"], input[type="radio"])::before {
        content: " ";
        width: 0;
        height: 3px;
        bottom: 0;
        background: #aea;
        position: absolute;
        right: auto;
        transition: width 0.15s, height 0.05s, bottom 0.25s, opacity 0.25s;
        left: auto;
        opacity: 0;
        z-index: -5;
        box-sizing: border-box;
      }
      .tooltip > * + *::after {
        content: " ";
        display: inline-block;
        width: 1px;
        height: calc(100% - 2px);
        background: #ffffff66;
        position: absolute;
        left: -2.5px;
        margin-block: 1px;
      }
      .timeline {
        display: flex;
        width: 100%;
        overflow: scroll;
      }
      .layers {
        width: calc(100% - 8em);
        min-width: max-content;
        height: 100%;
        padding: 0;
        padding-top: 1rem;
        margin: 0;
        background: #aaa;
        touch-action: none;
        box-sizing: border-box;
      }
      li-layer {
        display: flex;
        position: relative;
        width: inherit;
        min-width: 100%;
        height: 3em;
        background: #eeeeee;
        padding-top: 2px;
        padding-bottom: 2px;
        border-top: solid 1px #666;
        box-sizing: border-box;
      }
      .layer-tips {
        position: sticky;
        width: 8em;
        height: fit-content;
        min-height: 100%;
        left: 0;
        padding: 0;
        padding-top: 16px;
        margin: 0;
        background: #999999;
        box-sizing: border-box;
        z-index: 10;
      }
      .layer-tips .tips {
        height: 3em;
        width: 8em;
        background: #cccccc;
        border-top: solid 1px #666666;
        box-sizing: border-box;
      }
      .layer-tips .tips .buttons {
        display: flex;
        flex-direction: row;
        justify-content: space-every;
      }
      .layer-tips > .tips > .buttons > input[type="checkbox"] {
        display: inline-block;
        width: 50%;
        height: 1.5em;
        border: solid 1px #666666;
        border-radius: 4px;
        margin: 0.1em;
        appearance: none;
        background: #cccccc;
      }
      .layer-tips > .tips > .buttons > input[type="checkbox"]:checked {
        background: #666666;
      }
      .layer-tips > .tips > .buttons > input[type="checkbox"]::after {
        display: inline-flex;
        width: 100%;
        height: 100%;
        font-size: 1.2em;
        align-items: center;
        justify-content: center;
      }
      .layer-tips > .tips > .buttons > input[type="checkbox"]:checked::after {
        color: white;
      }
      .layer-tips > .tips > .buttons > input[type="checkbox"].solo::after {
        content: "solo";
      }
      .layer-tips> .tips > .buttons > input[type="checkbox"].mute::after {
        content: "mute";
      }
      .layer-tips> .tips > input[type="range"].volume {
        width: 100%;
        margin: 0;
      }
      src-obj {
        position: absolute;
        display: inline-flex;
        flex-direction: column;
        width: 100px;
        height: calc(3em - 4px);
        border-radius: 4px;
        box-sizing: border-box;
      }
      src-obj > label.name {
        font-size: 0.8em;
        max-width: 100%;
        height: 1.5em;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }
      src-obj > input[type="radio"] {
        display: none;
      }
      src-obj > div.focused {
        display: none;
      }
      src-obj > input[type="radio"]:checked ~ div.focused {
        display: inline-block;
        top: 0;
        left:0;
        width: 100%;
        height: calc(100% - 0.8em * 1.5);
        background: repeating-linear-gradient(60deg, #00000000, #00000000 0.5em, #ffffff33 0, #ffffff33 1.5em, #ffffff66 0, #ffffff66 2.5em);
        border-top: solid 2px white;
      }
      src-obj:has(input:checked) {
        box-shadow: inset 0 0 1px 1px #ffffff66;
      }
      src-obj[type="video"] {
        background: #3399ff;
        border: solid 1px #0066ff;
      }
      src-obj[type="audio"] {
        background: #ff9966;
        border: solid 1px #ff6600;
      }
      src-obj[type="image"] {
        background: #ff3366;
        border: solid 1px #ff0033;
      }
      src-obj[type="text"] {
        background: #999999;
        border: solid 1px #666666;
      }
      src-obj[type="shape"] {
        background: #33ff66;
        border: solid 1px #00ff33;
      }
      src-obj[type="effect"] {
        background: #ffcc33;
        border: solid 1px #cc9900;
      }
      src-obj[type="unknown"] {
        background: #cccccc;
        border: solid 1px #444444;
      }
      input[name="time"][type=range] {
        display: inline-flex;
        -webkit-appearance:none;
        position: sticky;
        top: 0;
        width: 100%;
        height: 100%;
        margin: 0;
        margin-top: -1rem;
        margin-bottom: -100%;
        border: none;
        background: transparent;
        align-items: flex-start;
        z-index: 5;
      }
      input[name="time"][type=range]::-webkit-slider-container {
        width: 100%;
        overflow-x: hidden;
      }
      input[name="time"][type=range]::-webkit-slider-runnable-track {
        width: calc(100% + 16px);
        height: 100%;
        margin-left: -8px;
        margin-right: -8px;
      }
      input[name="time"][type=range]::-webkit-slider-thumb {
        position: relative;
        -webkit-appearance: none;
        background-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMjU2IiB3aWR0aD0iMTZweCIgaGVpZ2h0PSIyNTZweCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz48L2RlZnM+CiAgPHJlY3Qgc3R5bGU9InBhaW50LW9yZGVyOiBmaWxsOyBmaWxsOiByZ2JhKDI1NSwgMTUzLCAxMDIsIDAuMjUpOyIgeD0iNiIgd2lkdGg9IjQiIGhlaWdodD0iMjU2Ij48L3JlY3Q+CiAgPHBhdGggZD0iTSA1LjUgMjU3IEwgNS41IC0xIEwgNi41IC0xIEwgNi41IDI1NyBMIDUuNSAyNTcgWiBNIDkuNSAyNTcgTCA5LjUgLTEgTCAxMC41IC0xIEwgMTAuNSAyNTcgTCA5LjUgMjU3IFoiIHN0eWxlPSJmaWxsOiByZ2IoMjU1LCAxMDIsIDUxKTsiPjwvcGF0aD4KPC9zdmc+");
        top: 0;
        width: 16px;
        height: 100%;
        border-top: solid 16px transparent;
        border-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMTYiIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE2cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6Yng9Imh0dHBzOi8vYm94eS1zdmcuY29tIj4KICA8ZGVmcz48L2RlZnM+CiAgPHBvbHlnb24gc3R5bGU9ImZpbGw6IHJnYigyNTUsIDEwMiwgMCk7IHN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBwYWludC1vcmRlcjogc3Ryb2tlOyBzdHJva2Utd2lkdGg6IDJweDsgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDsiIHBvaW50cz0iMSAxLjAwMyAxNSAxIDE0Ljk5OCAxMS41MDEgNy45OTkgMTUgMSAxMS41MDEiPjwvcG9seWdvbj4KICA8cGF0aCBzdHlsZT0iZmlsbDogcmdiKDI1NSwgMjU1LCAyNTUpOyIgZD0iTSA3IDIgSCA5IFYgMTMgQSAxIDEgMCAwIDEgOCAxNCBIIDggQSAxIDEgMCAwIDEgNyAxMyBWIDIgWiIgYng6c2hhcGU9InJlY3QgNyAyIDIgMTIgMCAwIDEgMSAxQDJlNDU4NGY4Ij48L3BhdGg+Cjwvc3ZnPg==") 16 0 0 / 16px 0 0 0 / 0px round;
      }
      input[name="time"][type=range]::-ms-tooltip {
        display:none;
      }
      input[name="time"][type=range]::-moz-range-track {
        width: calc(100% + 16px);
        height: 100%;
        margin-left: -8px;
        margin-right: -8px;
      }
      input[name="time"][type=range]::-moz-range-thumb {
        display:block;
        position: relative;
        -webkit-appearance: none;
        background-color: transparent;
        background-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMjU2IiB3aWR0aD0iMTZweCIgaGVpZ2h0PSIyNTZweCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz48L2RlZnM+CiAgPHJlY3Qgc3R5bGU9InBhaW50LW9yZGVyOiBmaWxsOyBmaWxsOiByZ2JhKDI1NSwgMTUzLCAxMDIsIDAuMjUpOyIgeD0iNiIgd2lkdGg9IjQiIGhlaWdodD0iMjU2Ij48L3JlY3Q+CiAgPHBhdGggZD0iTSA1LjUgMjU3IEwgNS41IC0xIEwgNi41IC0xIEwgNi41IDI1NyBMIDUuNSAyNTcgWiBNIDkuNSAyNTcgTCA5LjUgLTEgTCAxMC41IC0xIEwgMTAuNSAyNTcgTCA5LjUgMjU3IFoiIHN0eWxlPSJmaWxsOiByZ2IoMjU1LCAxMDIsIDUxKTsiPjwvcGF0aD4KPC9zdmc+");
        width: 16px;
        height: 100%;
        border-top: solid 16px transparent;
        border-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMTYiIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE2cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6Yng9Imh0dHBzOi8vYm94eS1zdmcuY29tIj4KICA8ZGVmcz48L2RlZnM+CiAgPHBvbHlnb24gc3R5bGU9ImZpbGw6IHJnYigyNTUsIDEwMiwgMCk7IHN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBwYWludC1vcmRlcjogc3Ryb2tlOyBzdHJva2Utd2lkdGg6IDJweDsgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDsiIHBvaW50cz0iMSAxLjAwMyAxNSAxIDE0Ljk5OCAxMS41MDEgNy45OTkgMTUgMSAxMS41MDEiPjwvcG9seWdvbj4KICA8cGF0aCBzdHlsZT0iZmlsbDogcmdiKDI1NSwgMjU1LCAyNTUpOyIgZD0iTSA3IDIgSCA5IFYgMTMgQSAxIDEgMCAwIDEgOCAxNCBIIDggQSAxIDEgMCAwIDEgNyAxMyBWIDIgWiIgYng6c2hhcGU9InJlY3QgNyAyIDIgMTIgMCAwIDEgMSAxQDJlNDU4NGY4Ij48L3BhdGg+Cjwvc3ZnPg==") 16 0 0 / 16px 0 0 0 / 0px round;
      }
      @-moz-document url-prefix() {
        input[name="time"][type=range] {
          padding-top: 8px;
          margin-left: -8px;
          margin-right: -8px;
          width: calc(100% + 16px);
        }
      }
      .layers > .sequence-scale {
        display: inline-flex;
        position: sticky;
        top: 0;
        width: 100%;
        height: 1rem;
        margin: 0;
        margin-top: -1rem;
        margin-bottom: calc(1em - 100%);
        border: none;
        background: #ccc;
        align-items: flex-start;
        overflow: hidden;
        box-sizing: border-box;
        z-index: 4;
      }
      .sequence-scale > span {
        height: 1rem;
        min-width: var(--scale-length);
        max-width: var(--scale-length);
        line-height: 100%;
        background: linear-gradient(45deg, black, white);
      }
      .layer-tips > .sequence-scale-spacer {
        position: sticky;
        top: 0;
        width: 100%;
        height: 1rem;
        margin-top: -1rem;
        background: #666;
      }
      .layers > div.wrapper {
        display: inline-block;
        position: sticky;
        top:0;
        left: 0;
        width: 100%;
        height: 100%;
        margin-bottom: -100%;
        z-index: 3;
      }
      input.switch[type="checkbox"] {
        display: inline-flex;
        appearance: unset;
        width: 3.5em;
        height: 2em;
        border-radius: 2em;
        border: solid 1px #444444;
        background-color: #ffffff;
        align-items: center;
        box-sizing: border-box;
      }
      input.switch[type="checkbox"][disabled] {
        background-color: #aaaaaa;
      }
      input.switch[type="checkbox"]:checked {
        background-color: #6666ff;
      }
      input.switch[type="checkbox"][disabled]:checked {
        background-color: #666699;
      }
      input.switch[type="checkbox"]::after {
        content: "";
        display: inline-block;
        position: relative;
        height: 80%;
        aspect-ratio: 1;
        margin: calc(8% - 0.5px);
        background-color: white;
        background-origin: content-box;
        border-style: solid;
        border-width: 1px;
        border-color: #333333;
        border-radius: 50%;
        padding: 5%;
        box-sizing: border-box;
        left: 0;
        background-size: contain;
        transition: left 0.15s cubic-bezier(0.67, -0.01, 0.1, 1.5);
      }
      input.switch[type="checkbox"][disabled]::after {
        background-color: #aaaaaa;
      }
      input.switch[type="checkbox"]:checked::after {
        left: 42%;
      }
      .detail label, .detail span {
        color: white;
        white-space: nowrap;
      }
      .detail .first {
        display: inline-flex;
        flex-direction: row;
        width: 100%;
      }
      .detail .first > div {
        width: 50%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: flex-start;
      }
      .detail .first > div > div {
        display: inline-flex;
        flex-wrap: nowrap;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }
      .detail .first > div > div > input, .detail .first > div > div > transitional-input, .detail .first > div > div > .inputs {
        width: calc(100% - 6rem);
      }
      .detail .inputs {
        display: inline-flex;
        flex-direction: row;
        align-items: center;
        width: calc(100% - 6rem);
      }
      .detail .inputs input, .detail .inputs transitional-input {
        width: 50%;
      }
      .detail .inputs .px, .details .inputs .percent {
        padding-right: 0.35em;
        border-right: solid 1px #ccc;
        margin-right: 0.35em;
        box-sizing: border-box;
      }
      .detail .inputs .px:last-child, .details .inputs .percent:last-child {
        padding-right: 0;
        border-right: 0;
        margin-right: 0;
      }
      .detail input[type="checkbox"][name="aspect-lock"] {
        appearance: none;
        width: 2em;
        height: 2em;
        margin: 0;
        background-color: #ffffff66;
        -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMTYiIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE2cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+ICA8ZGVmcz48L2RlZnM+ICA8cGF0aCBkPSJNIDEuOTkzIDYgTCAxMSA2IEMgMTEgNS42ODcgMTEgNS4zNTEgMTEgNSBDIDExIDMuMzQzIDkuNjU3IDIgOCAyIEMgNi4zNDMgMiA1IDMuMzQzIDUgNSBMIDMgNSBDIDMgMi4yMzkgNS4yMzkgMCA4IDAgQyAxMC43NjEgMCAxMyAyLjIzOSAxMyA1IEMgMTMgNS4zNzkgMTMgNS43MSAxMyA2IEwgMTQuMDMxIDYgQyAxNS4xMzYgNiAxNi4wMzEgNi44OTUgMTYuMDMxIDggTCAxNi4wMzEgMTQgQyAxNi4wMzEgMTUuMTA1IDE1LjEzNiAxNiAxNC4wMzEgMTYgTCAxLjk5MyAxNiBDIDAuODg4IDE2IC0wLjAwNyAxNS4xMDUgLTAuMDA3IDE0IEwgLTAuMDA3IDggQyAtMC4wMDcgNi44OTUgMC44ODggNiAxLjk5MyA2IFogTSA4IDggQyA2Ljg5NSA4IDYgOC44OTUgNiAxMCBDIDYgMTAuNzgzIDYuNDUgMTEuNDYxIDcuMTA1IDExLjc4OSBMIDYgMTQgTCAxMCAxNCBMIDguODk1IDExLjc4OSBDIDkuNTUgMTEuNDYxIDEwIDEwLjc4MyAxMCAxMCBDIDEwIDguODk1IDkuMTA1IDggOCA4IFoiIHN0eWxlPSJmaWxsOiByZ2IoMjE2LCAyMTYsIDIxNik7Ij48L3BhdGg+PC9zdmc+");
        -webkit-mask-size: contain;
        -webkit-mask-position: center;
        -webkit-mask-repeat: no-repeat;
      }
      .detail input[type="checkbox"][name="aspect-lock"]:checked {
        background-color: #ddddff;
        -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMTYiIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE2cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+ICA8ZGVmcz48L2RlZnM+ICA8cGF0aCBkPSJNIDMgNSBDIDMgMi4yMzkgNS4yMzkgMCA4IDAgQyAxMC43NjEgMCAxMyAyLjIzOSAxMyA1IEMgMTMgNS4zNzkgMTMgNS43MSAxMyA2IEwgMTQuMDMxIDYgQyAxNS4xMzYgNiAxNi4wMzEgNi44OTUgMTYuMDMxIDggTCAxNi4wMzEgMTQgQyAxNi4wMzEgMTUuMTA1IDE1LjEzNiAxNiAxNC4wMzEgMTYgTCAxLjk5MyAxNiBDIDAuODg4IDE2IC0wLjAwNyAxNS4xMDUgLTAuMDA3IDE0IEwgLTAuMDA3IDggQyAtMC4wMDcgNi44OTUgMC44ODggNiAxLjk5MyA2IEwgMyA2IEMgMyA1LjcxIDMgNS4zNzkgMyA1IFogTSAxMSA1IEMgMTEgMy4zNDMgOS42NTcgMiA4IDIgQyA2LjM0MyAyIDUgMy4zNDMgNSA1IEMgNSA1LjM1MSA1IDUuNjg3IDUgNiBMIDExIDYgQyAxMSA1LjY4NyAxMSA1LjM1MSAxMSA1IFogTSA4IDggQyA2Ljg5NSA4IDYgOC44OTUgNiAxMCBDIDYgMTAuNzgzIDYuNDUgMTEuNDYxIDcuMTA1IDExLjc4OSBMIDYgMTQgTCAxMCAxNCBMIDguODk1IDExLjc4OSBDIDkuNTUgMTEuNDYxIDEwIDEwLjc4MyAxMCAxMCBDIDEwIDguODk1IDkuMTA1IDggOCA4IFoiIHN0eWxlPSJmaWxsOiByZ2IoMjE2LCAyMTYsIDIxNik7Ij48L3BhdGg+PC9zdmc+");
      }
      .detail transitional-input {
        display: inline-flex;
        flex-direction: row;
        flex-wrap: nowrap;
        align-items: center;
      }
      .detail transitional-input > input[type="checkbox"] {
        appearance: none;
        width: 1.5rem;
        height: 1.5rem;
        -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTYgMTYiIHdpZHRoPSIxNnB4IiBoZWlnaHQ9IjE2cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogIDxkZWZzPjwvZGVmcz4NCiAgPHBhdGggZD0iTSAwLjA0MTAwMDAwMTEzMjQ4ODI1IDAuMDMyOTk5OTk5ODIxMTg2MDY2IEwgMC4wMTMwMDAwMDAyNjgyMjA5MDEgMTUuOTYwMDAwMDM4MTQ2OTczIEwgMTYgOCBaIiBzdHlsZT0iIj48L3BhdGg+DQo8L3N2Zz4=");
        -webkit-mask-size: 80%;
        -webkit-mask-repeat: no-repeat;
        -webkit-mask-position: center;
        box-sizing: border-box;
        margin: 0;
        background-color: #666666;
      }
      .detail transitional-input > input[type="checkbox"]:checked {
        background-color: #dddddd;
      }
      .detail transitional-input > input[type="checkbox"] + input {  
        display: none;
      }
      .detail transitional-input > input[type="checkbox"]:checked + input {
        display: inline-block;
      }
      .detail transitional-input:has(input[type="checkbox"]) > input:not([type="checkbox"]) {
        width: calc(100% - 1.5rem);
      }
      .detail transitional-input:has(input[type="checkbox"]:checked) > input:not([type="checkbox"]) {
        width: calc(50% - 0.75rem);
      }
      pop-up#loading > .body {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
      }
      .cover {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        backdrop-filter: blur(2px);
        z-index: 100;
        background: #00000033;
      }
    </style>
    <style id="dynamic">
      .layers, .layers * {
        --unit-length: 1px;
      }
      .preview, .preview * {
        --unit-px: 1px;
        --preview-width: 1920;
        --preview-height: 1080;
      }
      .sequence-scale, .sequence-scale > span {
      }
    </style>
    <script>
      class HTMLLayerElement extends HTMLElement {
        #solo;
        #mute;
        #state;
        #volume;
        #tips;
        #constructed = false;
        constructor() {
          super();
          if (this.#constructed) {
            return;
          }
          this.#constructed = true;
          this.#state = 0;
          this.#tips = document.createElement("div");
          this.#tips.setAttribute("class", "tips");
          let buttons = document.createElement("div");
          buttons.setAttribute("class", "buttons");
          this.#solo = document.createElement("input");
          this.#mute = document.createElement("input");
          this.#volume = document.createElement("input");
          this.#solo.setAttribute("type", "checkbox");
          this.#mute.setAttribute("type", "checkbox");
          this.#solo.setAttribute("class", "solo");
          this.#mute.setAttribute("class", "mute");
          this.#volume.setAttribute("type", "range");
          this.#volume.setAttribute("min", "0");
          this.#volume.setAttribute("max", "100");
          this.#volume.setAttribute("class", "volume");
          buttons.appendChild(this.#solo);
          buttons.appendChild(this.#mute);
          this.#tips.appendChild(buttons);
          this.#tips.appendChild(this.#volume);
          setTimeout(()=>{
          }, 0);
        }
        connectedCallback() {
          document.getElementsByClassName("layer-tips")[0].appendChild(this.#tips);
        }
        disconnectedCallback() {
          this.#tips.remove();
        }
      }
      class HTMLSourceObjectElement extends HTMLElement {
        TYPES = {VIDEO:"動画", AUDIO:"音声", IMAGE:"画像", TEXT:"テキスト", SHAPE:"図形", EFFECT:"効果"}
        #label;
        #radio;
        #constructed = false;
        constructor() {
          super();
          let name = "untitled";
          this.__srcObj = undefined;
          this.#label = document.createElement("label");
          this.#label.setAttribute("class", "name");
          this.#radio = document.createElement("input");
          this.#radio.setAttribute("name", "src-focused");
          this.#radio.setAttribute("type", "radio");
          let back = document.createElement("div");
          back.setAttribute("class", "focused");
          this.#constructed = true;
          setTimeout(()=>{
            this.setAttribute("tabindex", "0");
            this.appendChild(this.#label);
            this.appendChild(this.#radio);
            this.appendChild(back);
            if (this.hasAttribute("type")) {
              ;//let type = this.getAttribute("type");
              ;//this.#label.innerText = name + "("+this.TYPES[type.toUpperCase()]+")";
            }
          }, 0); 
        }

        connectedCallback() {
          this.#label.innerText = this.getAttribute("name") + "("+this.TYPES[this.getAttribute("type").toUpperCase()]+")";
          this.addEventListener("click", this.showDetail);
        }

        disconnectedCallback() {
          this.removeEventListener("click", this.showDetail);
        }

        get srcObj() {
          return this.__srcObj;
        }

        set srcObj(value) {
          this.#radio.setAttribute("value", value.id);
          this.__srcObj = value;
        }

        showDetail(e) {
          if (e.target == this.#radio) {
            return;
          }
          this.#radio.click();
          if (this.__srcObj) {
            let el = this.__srcObj.detailElement;
            document.getElementsByClassName("detail")[0].replaceChildren(el);
          }
        }

        static get observedAttributes() {
          return ["name", "type"];
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (!this.#constructed) {
            setTimeout(()=>{this.attributeChangedCallback(name, oldValue, newValue);}, 100);
            console.log(123);
            return;
          }
          if (name == "name" || name == "type") {
            this.#label.innertext = newValue + "("+this.TYPES[this.getAttribute("type").toUpperCase()]+")";
          }
        }
      }
      class HTMLSeekBarElement extends HTMLElement {
        constructor() {
          super();
          this.__start = 0;
          this.__end = 0;
          this.__spans = [];
          this.startLabel = document.createElement("label");
          this.endLabel = document.createElement("label");
          this.__bar = document.createElement("div");
          setTimeout(()=>{
            this.append(this.startLabel, this.__bar, this.endLabel);
          }, 0)
        }
        get ranges() {
          return this.__bar.children;
        }
      }
      class HTMLTransitionalInputElement extends HTMLElement {
        constructor() {
          super();
          this.begin = document.createElement("input");
          this.end = document.createElement("input");
          this.switch = document.createElement("input");
          this.switch.setAttribute("type", "checkbox");
          this.switch.addEventListener("change", (e)=>{
            this.enabled = e.value;
          });
          this.__enabled = false;
          Object.defineProperty(this, "enabled", {
            get() {
              return this.__enabled;
            },
            set(value) {
              this.__enabled = value == true;
              this.switch.value = this.__enabled;
            }
          });
          setTimeout(()=>{
            this.append(this.begin, this.switch, this.end)
          }, 0);
        }
        static get observedAttributes() {
          return ["type","disabled"];
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (name == "type") {
            if (newValue) {
              this.begin.setAttribute("type", newValue);
              this.end.setAttribute("type", newValue);
            } else {
              this.begin.removeAttribute("type");
              this.end.removeAttribute("type");
            }
          } else if (name == "disabled") {
            if (newValue) {
              this.begin.setAttribute("disabled", "");
              this.end.setAttribute("disabled", "");
            } else {
              this.begin.removeAttribute("disabled");
              this.end.removeAttribute("disabled");
            }
          }
        }
      }
      class HTMLPopupElement extends HTMLElement {
        #header
        #body
        #ready
        #type
        #childcache
        #dragstart
        #cover
        constructor(type) {
          super();
          this.#ready = false;
          this.#body = document.createElement("div");
          this.#cover = document.createElement("div");
          this.#cover.setAttribute("class", "cover");
          this.#type = type?type.toUpperCase():undefined;
          setTimeout(()=>{
            var children = [...this.children, ...this.#body.children];
            this.#type = this.getAttribute("type") || this.#type;
            this.#type = this.#type?this.#type.toUpperCase():"NORMAL";
            for (let i of children) {
              i.remove();
            }
            console.log(children);
            if (this.#type == "NORMAL") {
              this.#header = document.createElement("div")
              this.#header.setAttribute("class", "header");
              var buttons = {close: document.createElement("button"), minimize: document.createElement("button")};
              for (let i of Object.values(buttons)) {
                i.appendChild(document.createElement("span"));
                i.children[0].setAttribute("class", "image");
              }
              buttons.close.setAttribute("class", "close");
              buttons.minimize.setAttribute("class", "minimize");
              this.#header.append(buttons.minimize, buttons.close);
              buttons.minimize.addEventListener("click", ()=>{
                if (this.hasAttribute("minimized")) {
                  this.removeAttribute("minimized");
                } else {
                  this.setAttribute("minimized", "");
                }
              });
              buttons.close.addEventListener("click", ()=>{
                this.removeAttribute("active");
              });
              this.appendChild(this.#header);
            } else if (this.#type == "MORDAL") {
              this.style.top = "50%";
              this.style.left = "50%";
              this.style.translate = "-50% -50%";
            }
            this.#body.remove();
            this.#body = document.createElement("div")
            this.#body.setAttribute("class", "body");
            this.#body.append(...children);
            this.appendChild(this.#body);
            this.#ready = true;
            console.log(this);
            this.addEventListener("mousedown", ()=>{this.raiseFront();});
            this.#dragstart = (e)=>{
              if (e.target != this.#header) { return; }
              e.preventDefault();
              if (e.type == "touchstart") { e = e.touches[0]; }
              var rect = this.getBoundingClientRect();
              var x = rect.x;
              var y = rect.y;
              var aborter = new AbortController();
              var move = (ev)=>{
                if (ev.type == "touchmove") { ev = ev.touches[0]; }
                console.log([x + ev.clientX - e.clientX, y + ev.clientY - e.clientY]);
                this.style.left = x + ev.clientX - e.clientX + "px";
                this.style.top = y + ev.clientY - e.clientY + "px";
              };
              var stop = (ev)=>{
                aborter.abort();
              };
              window.addEventListener("mousemove", move, {signal:aborter.signal});
              window.addEventListener("mouseup", stop, {signal: aborter.signal});
              window.addEventListener("touchmove", move, {signal:aborter.signal});
              window.addEventListener("touchend", stop, {signal: aborter.signal});
            };
            this.dispatchEvent(new Event("ready"));
          }, 0);
        }
        get body() {
          return this.#body;
        }
        appendChild(node) {
          if (node == this.#header || node == this.#body) {
            super.appendChild(node);
          } else {
            this.#body.append(node);
          }
        }
        append(...nodes) {
          this.#body.append(...nodes);
        }
        activate() {
          this.setAttribute("active", "");
          if (this.hasAttribute("minimized")) {
            this.removeAttribute("minimized");
          }
        }
        close() {
          try {
            this.removeAttribute("active")
          } catch {
            ;
          }
          if (this.hasAttribute("minimized")) {
            this.removeAttribute("minimized");
          }
        }
        static get observedAttributes() {
          return ["active"];
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (this.type == undefined) {
            this.type = this.getAttribute("type");
          }
          if (name=="active" && oldValue == null) {
            var rect = this.getBoundingClientRect();
            var rect2 = document.body.getBoundingClientRect();
            if (this.#type == "NORMAL") {
              this.style.top = (rect2.height - rect.height) / 2 + "px";
              this.style.left = (rect2.width - rect.width) / 2 + "px";
              this.#header.addEventListener("mousedown", this.#dragstart);
              this.#header.addEventListener("touchstart", this.#dragstart);
            } else if (this.#type == "MORDAL") {
              document.body.appendChild(this.#cover);
            }
            this.raiseFront();
          } else if (name == "active" && newValue == null) {
            if (this.#type == "NORMAL") {
              this.#header.removeEventListener("mousedown", this.#dragstart);
              this.#header.removeEventListener("touchstart", this.#dragstart);
            } else if (this.#type == "MORDAL") {
              this.#cover.remove();
            }
          }
        }
        raiseFront() {
          [...this.parentElement.children].filter((i)=>i!=this).reverse().forEach((i)=>{
            this.parentElement.insertAdjacentElement("afterbegin", i);
          });
        }
      }
      class HTMLColorPickerElement extends HTMLElement {
        #input;
        constructor() {
          super();
          setTimeout(()=>{
            this.#input = document.createElement("input");
            this.appendChild(this.#input);
            this.#input.type = "color";
            this.style.background = this.#input.value;
            this.#input.addEventListener("input", (e)=>{
              this.style.background = this.#input.value;
            });
            this.addEventListener("click", (e)=>{this.#input.click();});
          }, 0);
        }
        get value() {
          return this.#input.value;
        }
        set value(value) {
          this.#input.value = value;
        }
      }
      customElements.define("li-layer", HTMLLayerElement);
      customElements.define("src-obj", HTMLSourceObjectElement);
      customElements.define("seek-bar", HTMLSeekBarElement);
      customElements.define("transitional-input", HTMLTransitionalInputElement);
      customElements.define("pop-up", HTMLPopupElement);
      customElements.define("color-picker", HTMLColorPickerElement);
    </script>
  </head>
  <body>
    <nav>
      <div class="menu">
        <div class="item">
          <div class="label">
            File
          </div>
          <div class="drop">
            <div class="child">
              <button name="newpro" type="button">
                <span class="title">New project</span>
                <span class="sub">Ctrl+Alt+N</span>
              </button>
            </div>
            <div class="child">
              <button name="openpro" type="button">
                <span class="title">Open project</span>
                <span class="sub">Ctrl+O</span>
              </button>
            </div>
            <div class="child">
              <button name="savepro" type="button">
                <span class="title">Save project</span>
                <span class="sub">Ctrl+S</span>
              </button>
            </div>
            <div class="child">
              <button name="import" type="button">
                <span class="title">Import</span>
                <span class="sub">Ctrl+I</span>
              </button>
            </div>
            <div class="child">
              <button name="encode" type="popup">Encode</button>
            </div>
            <div class="child">
              <button name="about" type="button" disabled>About</button>
            </div>
          </div>
        </div>
        <div class="item">
          <div class="label">Edit</div>
          <div class="drop">
            <div class="child">
              <button name="create-text" type="button">Create text</button>
            </div>
            <div class="child">
              <button name="search" type="button" disabled>Search</button>
            </div>
            <div class="child">
              <button name="replace" type="button" disabled>Replace</button>
            </div>
            <div class="child">
              <button name="select-all" type="button" disabled>Select ALL</button>
            </div>
            <div class="child"></div>
          </div>
        </div>
        <div class="item">
          <div class="label">Options</div>
          <div class="drop">
            <div class="child">
              <button name="project-settings" type="popup">Project Settings</button>
            </div>
            <div class="child">
              <button name="settings" type="button">Settings</button>
            </div>
          </div>
        </div>
      </div>
    </nav>
    <div class="main">
      <div class="area above">
        <div class="preview-box">
          <div class="preview">
          </div>
        </div>
        <div class="detail">
        </div>
      </div>
      <div class="tooltip">
        <button name="play-preview">Play</button>
        <button name="stop-preview">Stop</button>
        <div hidden>
        <input name="mode" value="play" type="radio">
        <input name="mode" value="forward" type="radio">
        <input name="mode" value="backward" type="radio">
        <button>Select-before</button>
        <button>Select-after</button>
        <button>copy</button>
        <button>paste</button>
        <button>cut</button>
        <button>delete</button>
        </div>
      </div>
      <div class="area below">
        <div class="timeline">
          <ul class="layer-tips">
            <div class="sequence-scale-spacer"></div>
          </ul>
          <ul class="layers">
            <input name="time" type="range">
            <span class="sequence-scale"></span>
            <div class="wrapper"></div>
            <li-layer index="0">
            </li-layer>
          </ul>
        </div>
      </div>
      <div class="side-panel">
        <input type="checkbox" class="nob">
      </div>
    </div>
    <pop-up id="loading" type="mordal">
      <div>
        <label>読み込み中...</label>
      </div>
    </pop-up>
    <pop-up id="demo-description" type="mordal">
      <div style="margin:1em;">
        <h2>使い方</h2>
        <p>左上の「File」→「Load project」をクリックすると、デモ用のデータが読み込まれます。</p>
        <p>それぞれの動画要素がドラッグして移動することができます。</p>
        <p>動画要素の長さは、動画要素をクリックで選択したあと、右上の詳細ウィンドウの「ソースの長さ」または「表示する機関」を変更することで調節できます。</p>
        <p>エンコードするには、「File」→「Encode」をクリックして、表示されたウィンドウの「送信」ボタンを押してください。</p>
        <p>(※「送信」というテキストですが外部に送信はされません。)</p>
        <p>デモ用モードなので、動画の長さは10秒までで終了します。</p>
        <p>エンコード後、出来上がった動画を再生できます。</p>
        <button style="margin-inline: calc(50% - 3em); text-wrap: nowrap; width: 6em;" onclick="document.querySelector('pop-up#demo-description').close()">閉じる</button>
      </div>
    </pop-up>
    <pop-up id="encode">
      <style>
        pop-up#encode {
        }
      </style>
      <form name="encode-options">
        <div>
          <label>File name:</label>
          <input type="text" value="output.mp4" required>
        </div>
        <div>
          <label>Format:</label>
          <select name="format" required disabled>
            <option value="mp4" selected>MP4</option>
          </select>
        </div>
        <section>
          <h3 style="
          display: flex;
          flex-wrap: nowrap;
          justify-content: space-between;
          align-items: center;">Video<input name="venabled" type="checkbox" class="switch" disabled checked></h3>
          <div>
            <label>Codec:</label>
            <select name="vcodec" required disabled>
              <option selected value="avc1">H.264</option>
            </select>
          </div>
          <div>
            <label>Frame rate:</label>
            <input name="vfps" type="number" value="30" disabled>
          </div>
        </section>
        <section>
          <h3 style="
          display: flex;
          flex-wrap: nowrap;
          justify-content: space-between;
          align-items: center;">Audio<input name="aenabled" type="checkbox" class="switch" disabled checked></h3>
          <div>
            <label>Codec:</label>
            <select name="acodec" required disabled>
              <option value="aac-lc" selected>AAC LC</option>
            </select>
          </div>
          <div>
            <label>Sample rate:</label>
            <input name="samplerate" type="number" value="48000" disabled>
          </div>
          <div>
            <label>Stereo audio:</label>
            <input name="stereo" type="checkbox" class="switch" disabled checked>
          </div>
        </section>
        <div style="
        display: flex;
        justify-content: space-evenly;">
          <button name="cancel">cancel</button>
          <input name="start" type="submit" label="start">
          <script>
            document.addEventListener("DOMContentLoaded", ()=>{
              document.querySelector("button[name=\"cancel\"]").addEventListener("click", (e)=>{
                e.preventDefault();
                e.stopImmediatePropagation();
                e.target.parentNode.parentNode.parentNode.parentNode.close();
              });
              document.querySelector("form[name=\"encode-options\"]").addEventListener("submit", (e)=>{
                e.preventDefault();
                e.stopImmediatePropagation();
                e.target.parentNode.parentNode.close();
                main.encode();
              });
            });
          </script>
        </div>
      </form>
    </pop-up>
    <pop-up id="encoding" type="mordal">
      <div style="display: flex; flex-direction: column; align-items: center;">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 480" width="640px" height="480px" xmlns:bx="https://boxy-svg.com">
          <style>
            g.src > rect {
              fill: none;
              stroke: none;
            }
            g.src.unknown > rect {
              fill: url("pattern-0");
              stroke: #444444;
            }
            g.src.video > rect{
              fill: url("#pattern-1");
              stroke: #0066ff;
            }
            g.src.audio > rect {
              fill: url("#pattern-2");
              stroke: #ff6600;
            }
            g.src.image > rect {
              fill: url("#pattern-3");
              stroke: #ff0033;
            }
            g.src.text > rect {
              fill: url("#pattern-4");
              stroke: #666666;
            }
            g.src.shape > rect {
              fill: url("#pattern-5");
              stroke: #00ff33;
            }
            g.src.effect > rect {
              fill: url("#pattern-6");
              stroke: #cc9900;
            }
          </style>
          <defs>
            <linearGradient gradientUnits="userSpaceOnUse" x1="0" y1="320" x2="0" y2="476" id="gradient-0" gradientTransform="matrix(1, 0, 0, 1, 16, 0)">
              <stop offset="0" style="stop-color: rgb(159, 159, 159);"></stop>
              <stop offset="1" style="stop-color: rgb(64, 64, 64)"></stop>
            </linearGradient>
            <mask id="mask-0">
              <rect style="fill: rgb(255, 255, 255);" x="80" y="156" width="480" height="320" rx="32" ry="32"></rect>
            </mask>
            <pattern x="0" y="0" width="25" height="25" patternUnits="userSpaceOnUse" viewBox="0 0 100 100" id="pattern-0-src">
              <rect width="100.035" height="100" style="fill: #cccccc;"></rect>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="0 0 80 0 100 20 100 100"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="40 0 80 0 100 20 100 60"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20 79.975 20 79.975 100" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000008)"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20.01799964904785 40 20 80 60.018001556396484 80 100.01799774169922" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000005)"></polygon>
            </pattern>
            <pattern x="0" y="0" width="25" height="25" patternUnits="userSpaceOnUse" viewBox="0 0 100 100" id="pattern-1-src">
              <rect width="100.035" height="100" style="fill: #3399ff;"></rect>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="0 0 80 0 100 20 100 100"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="40 0 80 0 100 20 100 60"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20 79.975 20 79.975 100" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000008)"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20.01799964904785 40 20 80 60.018001556396484 80 100.01799774169922" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000005)"></polygon>
            </pattern>
            <pattern x="0" y="0" width="25" height="25" patternUnits="userSpaceOnUse" viewBox="0 0 100 100" id="pattern-2-src">
              <rect width="100.035" height="100" style="fill: #ff9966;"></rect>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="0 0 80 0 100 20 100 100"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="40 0 80 0 100 20 100 60"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20 79.975 20 79.975 100" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000008)"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20.01799964904785 40 20 80 60.018001556396484 80 100.01799774169922" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000005)"></polygon>
            </pattern>
            <pattern x="0" y="0" width="25" height="25" patternUnits="userSpaceOnUse" viewBox="0 0 100 100" id="pattern-3-src">
              <rect width="100.035" height="100" style="fill: #ff3366;"></rect>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="0 0 80 0 100 20 100 100"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="40 0 80 0 100 20 100 60"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20 79.975 20 79.975 100" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000008)"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20.01799964904785 40 20 80 60.018001556396484 80 100.01799774169922" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000005)"></polygon>
            </pattern>
            <pattern x="0" y="0" width="25" height="25" patternUnits="userSpaceOnUse" viewBox="0 0 100 100" id="pattern-4-src">
              <rect width="100.035" height="100" style="fill: #999999;"></rect>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="0 0 80 0 100 20 100 100"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="40 0 80 0 100 20 100 60"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20 79.975 20 79.975 100" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000008)"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20.01799964904785 40 20 80 60.018001556396484 80 100.01799774169922" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000005)"></polygon>
            </pattern>
            <pattern x="0" y="0" width="25" height="25" patternUnits="userSpaceOnUse" viewBox="0 0 100 100" id="pattern-5-src">
              <rect width="100.035" height="100" style="fill: #33ff66;"></rect>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="0 0 80 0 100 20 100 100"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="40 0 80 0 100 20 100 60"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20 79.975 20 79.975 100" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000008)"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20.01799964904785 40 20 80 60.018001556396484 80 100.01799774169922" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000005)"></polygon>
            </pattern>
            <pattern x="0" y="0" width="25" height="25" patternUnits="userSpaceOnUse" viewBox="0 0 100 100" id="pattern-6-src">
              <rect width="100.035" height="100" style="fill: #ffcc33;"></rect>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="0 0 80 0 100 20 100 100"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2);" points="40 0 80 0 100 20 100 60"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20 79.975 20 79.975 100" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000008)"></polygon>
              <polygon style="fill: rgba(255, 255, 255, 0.2); transform-box: fill-box; transform-origin: 50% 50%;" points="0 20.01799964904785 40 20 80 60.018001556396484 80 100.01799774169922" transform="matrix(-1, 0, 0, -1, 0.000007, 0.000005)"></polygon>
            </pattern>
            <pattern id="pattern-0" href="#pattern-0-src" patternTransform="matrix(1.333333, 0, 0, 1.333333, 686.432894, 161.028779)"></pattern>
            <pattern id="pattern-1" href="#pattern-1-src" patternTransform="matrix(1.333333, 0, 0, 1.333333, 686.432894, 161.028779)"></pattern>
            <pattern id="pattern-2" href="#pattern-2-src" patternTransform="matrix(1.333333, 0, 0, 1.333333, 686.432894, 161.028779)"></pattern>
            <pattern id="pattern-3" href="#pattern-3-src" patternTransform="matrix(1.333333, 0, 0, 1.333333, 686.432894, 161.028779)"></pattern>
            <pattern id="pattern-4" href="#pattern-4-src" patternTransform="matrix(1.333333, 0, 0, 1.333333, 686.432894, 161.028779)"></pattern>
            <pattern id="pattern-5" href="#pattern-5-src" patternTransform="matrix(1.333333, 0, 0, 1.333333, 686.432894, 161.028779)"></pattern>
            <pattern id="pattern-6" href="#pattern-6-src" patternTransform="matrix(1.333333, 0, 0, 1.333333, 686.432894, 161.028779)"></pattern>
          </defs>
          <rect y="46" width="640" height="4" style="fill: rgb(138, 138, 138);"></rect>
          <g class="src video">
            <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.2;0.275;1" values="12,0;-340,0;-340,0;-340,240;-340,240;" />
            <rect x="628" y="80" width="64" height="64" rx="8" ry="8">
              <animateTransform attributeName="transform" type="rotate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;1" values="-7,660,32;-7,660,32;0,660,32;5,660,32;0,660,32;0,660,32;" />
            </rect>
          </g>
          <g  class="src audio">
            <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.2;0.3;0.375;1" values="12,0;-340,0;-340,0;-420,0;-420,240;-420,240" />
            <rect x="708" y="80" width="64" height="64" rx="8" ry="8">
              <animateTransform attributeName="transform" type="rotate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;1" values="-7,740,32;-7,740,32;0,740,32;5,740,32;0,740,32;0,740,32;" />
            </rect>
          </g>
          <g class="src image">
            <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.2;0.4;0.475;1" values="12,0;-340,0;-340,0;-500,0;-500,240;-500,240" />
            <rect x="788" y="80" width="64" height="64" rx="8" ry="8">
              <animateTransform attributeName="transform" type="rotate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;1" values="-7,820,32;-7,820,32;0,820,32;5,820,32;0,820,32;0,820,32;" />
            </rect>
          </g>
          <g class="src text">
            <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.2;0.5;0.575;1" values="12,0;-340,0;-340,0;-580,0;-580,240;-580,240" />
            <rect x="868" y="80" width="64" height="64" rx="8" ry="8">
              <animateTransform attributeName="transform" type="rotate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;1" values="-7,900,32;-7,900,32;0,900,32;5,900,32;0,900,32;0,900,32;" />
            </rect>
          </g>
          <g>
            <animateTransform name="hook-anime" attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.2;0.5;0.6;0.7;1" values="12,0;-340,0;-340,0;-580,0;-580,0;-934,0;-934,0" />
            <g>
              <path d="M 660 64 L 666 48 L 680 48 L 672 32 L 648 32 L 640 47.9 L 654 48 L 660 64 Z" style="fill: rgb(255, 192, 0); transform-origin: 660px 48px;"></path>
              <circle style="fill: rgb(255, 80, 0);" cx="660" cy="48" r="8"></circle>
              <circle style="fill: rgb(79, 79, 79);" cx="660" cy="64" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="1,0;1,0;0,0;-1,0;0,0;0,0;1,0;1,0;0,0;0,0" />
              </circle>
              <circle style="fill: rgb(79, 79, 79);" cx="660" cy="72" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="2,0;2,0;0,0;-2,0;0,0;0,0;2,0;2,0;0,0;0,0" />
              </circle>
              <circle style="fill: rgb(79, 79, 79);" cx="660" cy="80" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="4,0;4,0;0,0;-4,0;0,0;0,0;4,0;4,0;0,0;0,0" />
              </circle>
            </g>
            <g>
              <path d="M 740 64 L 746 48 L 760 48 L 752 32 L 728 32 L 720 47.9 L 734 48 L 740 64 Z" style="fill: rgb(255, 192, 0); transform-origin: 740px 48px;"></path>
              <circle style="fill: rgb(255, 80, 0);" cx="740" cy="48" r="8"></circle>
              <circle style="fill: rgb(79, 79, 79);" cx="740" cy="64" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="1,0;1,0;0,0;-1,0;0,0;0,0;1,0;1,0;0,0;0,0" />
              </circle>
              <circle style="fill: rgb(79, 79, 79);" cx="740" cy="72" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="2,0;2,0;0,0;-2,0;0,0;0,0;2,0;2,0;0,0;0,0" />
              </circle>
              <circle style="fill: rgb(79, 79, 79);" cx="740" cy="80" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="4,0;4,0;0,0;-4,0;0,0;0,0;4,0;4,0;0,0;0,0" />
              </circle>
            </g>
            <g>
              <path d="M 820 64 L 826 48 L 840 48 L 832 32 L 808 32 L 800 47.9 L 814 48 L 820 64 Z" style="fill: rgb(255, 192, 0); transform-origin: 820px 48px;"></path>
              <circle style="fill: rgb(255, 80, 0);" cx="820" cy="48" r="8"></circle>
              <circle style="fill: rgb(79, 79, 79);" cx="820" cy="64" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="1,0;1,0;0,0;-1,0;0,0;0,0;1,0;1,0;0,0;0,0" />
              </circle>
              <circle style="fill: rgb(79, 79, 79);" cx="820" cy="72" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="2,0;2,0;0,0;-2,0;0,0;0,0;2,0;2,0;0,0;0,0" />
              </circle>
              <circle style="fill: rgb(79, 79, 79);" cx="820" cy="80" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="4,0;4,0;0,0;-4,0;0,0;0,0;4,0;4,0;0,0;0,0" />
              </circle>
            </g>
            <g>
              <path d="M 900 64 L 906 48 L 920 48 L 912 32 L 888 32 L 880 47.9 L 894 48 L 900 64 Z" style="fill: rgb(255, 192, 0); transform-origin: 900px 48px;"></path>
              <circle style="fill: rgb(255, 80, 0);" cx="900" cy="48" r="8"></circle>
              <circle style="fill: rgb(79, 79, 79);" cx="900" cy="64" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="1,0;1,0;0,0;-1,0;0,0;0,0;1,0;1,0;0,0;0,0" />
              </circle>
              <circle style="fill: rgb(79, 79, 79);" cx="900" cy="72" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="2,0;2,0;0,0;-2,0;0,0;0,0;2,0;2,0;0,0;0,0" />
              </circle>
              <circle style="fill: rgb(79, 79, 79);" cx="900" cy="80" r="3">
                <animateTransform attributeName="transform" type="translate" dur="5s" repeatCount="indefinite" keyTimes="0;0.1;0.11;0.12;0.13;0.6;0.61;0.7;0.71;1" values="4,0;4,0;0,0;-4,0;0,0;0,0;4,0;4,0;0,0;0,0" />
              </circle>
            </g>
          </g>
          <g>
            <rect style="fill: rgb(69, 69, 69);" x="80" y="156" width="480" height="320" rx="32" ry="32"></rect>
            <g style="mask: url(#mask-0);">
              <path style="fill: url(#gradient-0);" d="M 720 480 L 80 480 L 80 343.999 C 102.092 312 137.909 312 160 344 C 182.092 375.999 217.909 375.999 240 344 C 262.092 312 297.909 312 320 344 C 342.092 375.999 377.909 375.999 400 344 C 422.092 312 457.909 312 480 344 C 502.092 375.999 537.909 375.999 560 344 C 582.092 312 617.909 312 640 344 C 662.092 375.999 697.909 375.999 720 344 L 720 480 Z">
                <animateTransform attributeName="transform" type="translate" dur="2s" repeatCount="indefinite" from="0,0" to="-160,0" />
              </path>
            </g>
            <path d="M 320 280 L 360 360 L 280 360 L 320 280 Z" bx:shape="triangle 280 280 80 80 0.5 0 1@a3f9afc4" style="fill: rgb(255, 255, 255); transform-box: fill-box; transform-origin: 50% 50%;" transform="matrix(0, 1, -1, 0, 0.00001, 0.000013)"></path>
          </g>
          <g>
            <animateTransform attributeName="transform" type="rotate" dur="1.5s" repeatCount="indefinite" keyTimes="0;0.5;1" values="0,72,400;45,72,400;45,72,400" />
            <path style="fill: rgb(205 72 72);" transform="matrix(0.614553, 0, 0, 0.614552, -75.02546, 62.98647)" d="M 226.499215715 444.248 L 251.980784285 444.248 L 256.661376868 485.675816601 A 65.088 65.088 0 0 1 271.26614353 491.725309028 L 303.869712334 465.741097735 L 321.887902265 483.759287666 L 295.903690972 516.36285647 A 65.088 65.088 0 0 1 301.953183399 530.967623132 L 343.381 535.648215715 L 343.381 561.129784285 L 301.953183399 565.810376868 A 65.088 65.088 0 0 1 295.903690972 580.41514353 L 321.887902265 613.018712334 L 303.869712334 631.036902265 L 271.26614353 605.052690972 A 65.088 65.088 0 0 1 256.661376868 611.102183399 L 251.980784285 652.53 L 226.499215715 652.53 L 221.818623132 611.102183399 A 65.088 65.088 0 0 1 207.21385647 605.052690972 L 174.610287666 631.036902265 L 156.592097735 613.018712334 L 182.576309028 580.41514353 A 65.088 65.088 0 0 1 176.526816601 565.810376868 L 135.099 561.129784285 L 135.099 535.648215715 L 176.526816601 530.967623132 A 65.088 65.088 0 0 1 182.576309028 516.36285647 L 156.592097735 483.759287666 L 174.610287666 465.741097735 L 207.21385647 491.725309028 A 65.088 65.088 0 0 1 221.818623132 485.675816601 Z M 239.24 515.845 A 32.544 32.544 0 0 0 239.24 580.933 A 32.544 32.544 0 0 0 239.24 515.845" bx:shape="cog 239.24 548.389 32.544 65.088 104.141 0.38 8 1@65085772"></path>
          </g>
          <path d="M 459.155 220 L 475.155 220 L 485.344 252 L 549.344 252 L 539.155 220 L 555.155 220 L 636.667 476 L 620.667 476 L 610.478 444 L 546.478 444 L 556.667 476 L 540.667 476 L 459.155 220 Z M 504.448 312 L 568.448 312 L 553.165 264 L 489.165 264 L 504.448 312 Z M 523.553 372 L 587.553 372 L 572.269 324 L 508.269 324 L 523.553 372 Z M 542.657 432 L 606.657 432 L 591.374 384 L 527.374 384 L 542.657 432 Z" style="fill: rgb(168, 150, 133);"></path>
        </svg>
        <progress style="width: 80%; margin: 2em;"></progress>
        <label style="margin: 1em;">エンコード中...</label>
      </div>
    </pop-up>
    <pop-up id="project-settings">
    </pop-up>
    <script>
      /* 表示幅-> 8こ分
         外側に1こずつ-> 計10こにする
      var sequence = document.getElementsByClassName("sequence")[0]; */
      var viewRange = [0, 1000]; // ms, start <= ~ < end
      var selectRange = [0, 0];
      var wholeRange = [0, 1000];
      handling = false;
      function drawSequence() {
        scrollLeft = document.getElementsByClassName("timeline")[0].scrollLeft;
        
        if (sequence.children.length < 10) {
          for (let i = sequence.children.length; i < 10; i++) {
            sequence.appendChild(((el)=>{el.innerHTML="<label></label>"; el.children[0].innerText = (wholeRange[1]-wholeRange[0])/((viewRange[1]-viewRange[0]) / 8);return el;})(document.createElement("span")));
          }
        }
      }
    </script>
    <script>
      for (let bt of document.getElementsByTagName("button")) {
        if (bt.getAttribute("type") == "popup") {
          bt.addEventListener("click", ()=>{
            document.getElementById(bt.getAttribute("name")).setAttribute("active", "");
          });
        }
      }
    </script>
    <script>
      const VERSION = "0.0.1";

      const AsyncFunction = Object.getPrototypeOf(async ()=>{}).constructor;

      function waitUntil(obj, event, options={callback:(e)=>e, timeout:3000, signal:undefined}) {
        return new Promise((resolve, reject)=>{
          let id;
          let listener = obj.addEventListener(event, async (e)=>{
            try {
              clearTimeout(id);
            } catch {}
            let result;
            if (Object.getPrototypeOf(async ()=>{}).isPrototypeOf(options.callback)) {
              result = await options.callback(e);
            } else if (options.callback != undefined){
              result = options.callback(e);
            } else {
              result = e;
            }
            resolve(result);
          }, {once: true, signal:options.signal});
          if (options.timeout != undefined) {
            id = setTimeout(()=>{
              try {
                obj.removeEventListener(listener);
              } catch {}
              reject();
            }, options.timeout);
          }
          if (options.signal != undefined) {
            options.signal.addEventListener("abort", (e)=>{
              try {
                clearTimeout(id);
              } catch {}
              reject();
            });
          }
        });
      }
 
      class TimeDelta extends Object {
        constructor(seconds) {
          super();
          this.millisecond = Math.round((seconds - Math.floor(seconds)) * 1000);
          seconds = Math.floor(seconds);
          this.second = seconds % 60;
          seconds = Math.round((seconds - this.second) / 60);
          this.minute = seconds % 60;
          seconds = Math.round((seconds - this.minute) / 60);
          this.hour = seconds;
        }
      }
      var SOURCE_TYPES = {
        UNKNOWN: 0,
        VIDEO: 1,
        AUDIO: 2,
        IMAGE: 3,
        TEXT: 4,
        SHAPE: 5,
        EFFECT: 6
      }
      var SOURCE_TYPE_TEXTS = {
        0: "unknown",
        1: "video",
        2: "audio",
        3: "image",
        4: "text",
        5: "shape",
        6: "effect"
      }

      var srcIds = [];
      var materialIds = [];

      function convertBigIntToArray(value, length) {
        let result = [];
        for (let i=BigInt(length-1); i >= 0n; i-=1n) {
          result.push(parseInt((value >> (i*8n)) & 0xffn));
        }
        return result;
      }

      function convertIntToArray(value, length) {
        let result = [];
        for (let i=length-1; i >= 0; i--) {
          result.push((value >>> (i*8)) & 0xff);
        }
        return result;
      }

      async function convertSVGToVideoFrame(svg, options) {
        let {ms=0, width, height} = options;
        if (SVGSVGElement.prototype.isPrototypeOf(svg)) {
          svg = svg.cloneNode(true);
        } else if (svg.toString != undefined) {
          let text = svg.toString();
          svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          let m = text.match(/<svg *(?<options>(?:(?:[a-zA-Z0-9:]+)(?:=(?:(?:'(?:[^']|\\')*')|(?:"(?:[^"]|\\")*")))? *)*) *>(?<innerHTML>(?:.|\s)*)<\/svg>/);
          if (m == undefined) {
            throw "given svg is not a svg.";
          }
          let options = m.groups.options.matchAll(/(?<key>[a-zA-Z0-9:]+)(?:=(?<quote>['"])(?<value>(?:(?!\k<quote>).|\\\k<quote>)*)\k<quote>)?/g);
          for (let option of options) {
            if (option.groups.key == "width" && width == undefined) {
              width = parseFloat(option.groups.value);
            }
            if (option.groups.key == "height" && height == undefined) {
              height = parseFloat(option.groups.value);
            }
            svg.setAttribute(option.groups.key, option.groups.value || "");
          }
          svg.innerHTML = m.groups.innerHTML;
        } else {
          throw "svg should be <svg> or svg text.";
        }
        svg.pauseAnimations();
        svg.setCurrentTime(ms/1000);
        svg.querySelectorAll("*").forEach((el)=>{el.transiton="";});
        svg.querySelectorAll("animate, animateTransform").forEach((el)=>{
          let key = el.getAttribute("attributeName");
          let value = el.parentNode.computedStyleMap().get(key).toString();
          el.parentNode.style[key.replaceAll(/(?<=\w)-(?<figure>\W)/g, "$<figure>")] = value;
          el.remove();
        });
        let img = document.createElement("img");
        img.src = "data:image/svg+xml;charset=utf-8;base64,"+btoa(svg.outerHTML.replaceAll(/[^\x00-\x7f]+/g, (m)=>unescape(encodeURIComponent(m))));
        img.style.width = width + "px";
        img.style.height = height + "px";
        img.setAttribute("width", Math.round(width));
        img.setAttribute("height", Math.round(height));
        await img.decode();
        let bitmap = await createImageBitmap(img, 0, 0, width, height, {resizeWidth:width, resizeHeight:height});
        let videoFrame = new VideoFrame(bitmap, {timestamp:ms});
        return videoFrame;
      }

      class Prompts {
        static show(element, buttons, iconUrl) {
          element = this.__checkText(element);
          let frame = document.createElement("div");
          let body = document.createElement("div");
          if (iconUrl) {
            let icon = document.createElement("img");
            icon.style.margin = "0.5rem";
            icon.src = iconUrl;
            body.append(icon);
            body.style.display = "inline-flex";
          }
          body.append(element);
          let btnarea = document.createElement("div");
          btnarea.setAttribute("class", "buttons");
          btnarea.append(...buttons);
          frame.append(body, btnarea);
          let popup = new HTMLPopupElement("mordal");
          popup.setAttribute("type", "mordal");
          popup.appendChild(frame);
          document.body.appendChild(popup);
          return popup;
        }
        static async showInfo(element) {
          let buttons = [
            this.__createButton("OK"),
          ];
          let popup = this.show(element, buttons, "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNjQgNjQiIHdpZHRoPSI2NHB4IiBoZWlnaHQ9IjY0cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogIDxkZWZzPjwvZGVmcz4NCiAgPGNpcmNsZSBzdHlsZT0iZmlsbDogcmdiKDEwMiwgMTAyLCAyNTUpOyIgY3g9IjMyIiBjeT0iMzIiIHI9IjMyIj48L2NpcmNsZT4NCiAgPHBhdGggc3R5bGU9ImZpbGw6IG5vbmU7IHN0cm9rZS13aWR0aDogOHB4OyBzdHJva2U6IHJnYigyNTUsIDI1NSwgMjU1KTsgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kOyBzdHJva2UtbGluZWpvaW46IHJvdW5kOyIgZD0iTSAyNCAzMiBMIDMyIDMyIEwgMzIgNTYgQyAzNiA1NiA0MCA1MiA0MCA1MiI+PC9wYXRoPg0KICA8Y2lyY2xlIHN0eWxlPSJmaWxsOiByZ2IoMjU1LCAyNTUsIDI1NSk7IiBjeD0iMzIiIGN5PSIxNiIgcj0iOCI+PC9jaXJjbGU+DQo8L3N2Zz4=");
          
          popup.activate();
          await waitUntil(buttons[0], "click", (e)=>{});
          popup.close();
          popup.remove();
          return;
        }
        static async showWarn(element) {
          let buttons = [
            this.__createButton("OK"),
          ];
          let popup = this.show(element, buttons);
          popup.activate();
          await waitUntil(buttons[0], "click", (e)=>{});
          popup.close();
          popup.remove();
          return;
        }
        static async showError(element) {
          let buttons = [
            this.__createButton("OK"),
          ];
          let popup = this.show(element, buttons, "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNjQgNjQiIHdpZHRoPSI2NHB4IiBoZWlnaHQ9IjY0cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogIDxkZWZzPjwvZGVmcz4NCiAgPGNpcmNsZSBzdHlsZT0iZmlsbDogcmdiKDI1NSwgNTEsIDUxKTsiIGN4PSIzMiIgY3k9IjMyIiByPSIzMiI+PC9jaXJjbGU+DQogIDxsaW5lIHN0eWxlPSJmaWxsOiByZ2IoMjE2LCAyMTYsIDIxNik7IHN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBzdHJva2Utd2lkdGg6IDhweDsgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kOyIgeDE9IjE2IiB5MT0iMTYiIHgyPSI0OCIgeTI9IjQ4Ij48L2xpbmU+DQogIDxsaW5lIHN0eWxlPSJmaWxsOiByZ2IoMjE2LCAyMTYsIDIxNik7IHN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBzdHJva2Utd2lkdGg6IDhweDsgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kOyIgeDE9IjQ4IiB5MT0iMTYiIHgyPSIxNiIgeTI9IjQ4Ij48L2xpbmU+DQo8L3N2Zz4=");
          popup.activate();
          await waitUntil(buttons[0], "click", (e)=>{});
          popup.close();
          popup.remove();
          return;
        }
        static async askOk(element) {
          let buttons = [
            this.__createButton("Yes"),
            this.__createButton("No"),
          ];
          let result = false;
          let popup = this.show(element, buttons, "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNjQgNjQiIHdpZHRoPSI2NHB4IiBoZWlnaHQ9IjY0cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogIDxkZWZzPjwvZGVmcz4NCiAgPGNpcmNsZSBzdHlsZT0iZmlsbDogcmdiKDEwMiwgMjU1LCA1MSk7IiBjeD0iMzIiIGN5PSIzMiIgcj0iMzIiPjwvY2lyY2xlPg0KICA8cGF0aCBzdHlsZT0iZmlsbDogbm9uZTsgc3Ryb2tlOiByZ2IoMjU1LCAyNTUsIDI1NSk7IHN0cm9rZS1saW5lY2FwOiByb3VuZDsgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDsgc3Ryb2tlLXdpZHRoOiA4cHg7IiBkPSJNIDE2IDMyIEwgMTYgMjAgQyAxNiA4IDQ4IDggNDggMjAgTCA0OCAzMiBDIDQ4IDQwIDMyIDMyIDMyIDQ0Ij48L3BhdGg+DQogIDxjaXJjbGUgc3R5bGU9ImZpbGw6IHJnYigyNTUsIDI1NSwgMjU1KTsiIGN4PSIzMiIgY3k9IjU2IiByPSI0Ij48L2NpcmNsZT4NCjwvc3ZnPg==");
          popup.activate();
          let aborter = new AbortController();
          let promises = [
            waitUntil(buttons[0], "click", {callback:(e)=>{return true;}, signal:aborter.signal}),
            waitUntil(buttons[1], "click", {callback:(e)=>{return false;}, signal:aborter.signal}),
          ];
          result = await Promise.any(promises);
          popup.close();
          popup.remove();
          return result;
        }
        static async askYN(element) {
          let buttons = [
            this.__createButton("Yes"),
            this.__createButton("No"),
          ];
          let result = false;
          let popup = this.show(element, buttons, "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgNjQgNjQiIHdpZHRoPSI2NHB4IiBoZWlnaHQ9IjY0cHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogIDxkZWZzPjwvZGVmcz4NCiAgPGNpcmNsZSBzdHlsZT0iZmlsbDogcmdiKDEwMiwgMjU1LCA1MSk7IiBjeD0iMzIiIGN5PSIzMiIgcj0iMzIiPjwvY2lyY2xlPg0KICA8cGF0aCBzdHlsZT0iZmlsbDogbm9uZTsgc3Ryb2tlOiByZ2IoMjU1LCAyNTUsIDI1NSk7IHN0cm9rZS1saW5lY2FwOiByb3VuZDsgc3Ryb2tlLWxpbmVqb2luOiByb3VuZDsgc3Ryb2tlLXdpZHRoOiA4cHg7IiBkPSJNIDE2IDMyIEwgMTYgMjAgQyAxNiA4IDQ4IDggNDggMjAgTCA0OCAzMiBDIDQ4IDQwIDMyIDMyIDMyIDQ0Ij48L3BhdGg+DQogIDxjaXJjbGUgc3R5bGU9ImZpbGw6IHJnYigyNTUsIDI1NSwgMjU1KTsiIGN4PSIzMiIgY3k9IjU2IiByPSI0Ij48L2NpcmNsZT4NCjwvc3ZnPg==");
          popup.activate();
          let aborter = new AbortController();
          let promises = [
            waitUntil(buttons[0], "click", {callback:(e)=>{return true;}, signal:aborter.signal}),
            waitUntil(buttons[1], "click", {callback:(e)=>{return false;}, signal:aborter.signal}),
          ];
          result = await Promise.any(promises);
          popup.close();
          popup.remove();
          return result;
        }
        static __checkText(element) {
          if (!Node.prototype.isPrototypeOf(element)) {
            let text = element.toString();
            element = document.createElement("p");
            element.innerText = text;
            element.setAttribute("style", "white-space:pre-line;");
          }
          return element;
        }
        static __createButton(label) {
          let btn = document.createElement("button");
          btn.innerText = label;
          return btn;
        }
      }

      class SourceClassTree {
        #classes;
        constructor() {
          this.#classes = [];
        }
        get classes() {
          return this.#classes
        }
        register(cls, callback=()=>false, type=SOURCE_TYPES.UNKNOWN) {
          if (!SourceBase.isPrototypeOf(cls)) {
            throw "cls is not a source class";
          } else if (!Function.prototype.isPrototypeOf(callback) && !AsyncFunction.prototype.isPrototypeOf(callback)) {
            throw "callback is not a function nor an async function";
          }
          let index = this.#classes.findIndex((i)=>i.cls==cls);
          if (index < 0) {
            this.#classes.splice(0, 0, {cls:cls, callback:callback, type:type});
          } else {
            this.#classes.at(index).callback = callback;
          }
        }
        async getSourceClass(file) {
          if (!File.prototype.isPrototypeOf(file)) {
            throw "file is not a file";
          }
          for (let i of this.#classes) {
            let check = i.check;
            let result;
            try {
              let result = check(file);
              if (Promise.prototype.isPrototypeOf(result)) {
                result = await result;
              }
            } catch(e) {
              console.warn("cls callback threw an error, ignored:", e);
            }
            if (result) {
              return i.cls;
            }
          }
        }
        getSourceClassFromType(type) {
          for (let i of this.#classes) {
            if (i.type == type) {
              return i.cls;
            }
          }
        }
      }

      class SourceOption extends EventTarget {
        constructor(option, srcobj) {
          super();
          this.__span = [];
          this.__srcobj = srcobj;
          this.__option = option; //["__"+i[0]] = i[1];
          this.__keys = Object.keys(option);
          for (let key of this.__keys) {
            if (OptionValue.prototype.isPrototypeOf(this.__option[key])) {
              this.__option[key].onchange = ()=>{
                this[key] = this[key];
              };
            }
            Object.defineProperty(this, key, {
              get: () => {
                return this.__option[key];
              },
              set: (value) => {
                let ev = new Event("change");
                let ev2 = new Event("change-"+key);
                ev.key = key;
                ev.value = value;
                ev.oldValue = this.__option[key];
                ev2.value = value;
                ev2.oldValue = this.__option[key];
                this.__option[key] = value;
                this.dispatchEvent(ev);
                this.dispatchEvent(ev2);
              }
            });
          }
          this.addEventListener("change-frames", (e)=>{
            this.length = this.frames[1] - this.frames[0];
            this.__srcobj.style.left = "calc(var(--unit-length) * "+this.frames[0]+" / 1000)";
            this.__srcobj.style.width = "calc(var(--unit-length) * "+this.length+" / 1000)";
          });
        }
        redraw() {
          for (let key of this.__keys) {
            this[key] = this[key];
          }
        }
        setTime(value) {
          for (let key of this.__keys) {
            this.__option[key].time = value;
          }
          this.redraw();
        }
        addKey(key, value) {
          if (this.__option.hasOwnProperty(key)) {
            this.__option[key] = value;
            return;
          }
          this.__option[key] = value;
          if (OptionValue.prototype.isPrototypeOf(value)) {
            value.onchange = ()=>{
              this[key] = this[key];
            };
          }
          Object.defineProperty(this, key, {
            get: () => {
              return this.__option[key];
            },
            set: (value) => {
              let ev = new Event("change");
              let ev2 = new Event("change-"+key);
              ev.key = key;
              ev.value = value;
              ev.oldValue = this.__option[key];
              ev2.value = value;
              ev2.oldValue = this.__option[key];
              this.__option[key] = value;
              this.dispatchEvent(ev);
              this.dispatchEvent(ev2);
            }
          });
        }
      }

      class OptionValue extends Object {
        static LINEAR = 0;
        constructor(option) {
          super();
          if (!Object.prototype.isPrototypeOf(option)) {
            option = {begin: option, end: option};
          }
          let {begin=undefined, end=undefined, type=this.constructor.LINEAR} = option;
          this.__begin = begin;
          this.__end = end;
          this.__type = type;
          this.__time = 0;
          this.__onchange = ()=>{};
          Object.defineProperties(this, {
            begin: {
              get() {
                return this.__begin;
              },
              set(value) {
                this.__begin = value;
                this.onchange();
              }
            },
            end: {
              get() {
                return this.__end;
              },
              set(value) {
                this.__end = value;
                this.onchange();
              }
            },
            type: {
              get() {
                return this.__type;
              },
              set(value) {
                this.__type = value;
                this.onchange();
              }
            },
            curValue: {
              get() {
                if (true || this.__type == constructor.LINEAR) {
                  return this.__begin * (1 - this.__time) + this.__end * this.__time;
                }
              },
              set() {}
            },
            time: {
              get() {
                return this.__time;
              },
              set(value) {
                this.__time = value;
                this.onchange();
              }
            },
            onchange: {
              get() {
                return this.__onchange;
              },
              set(value) {
                console.log(value);
                this.__onchange = value;
              }
            }
          });
        }
      }

      class Material extends Object {
        constructor(fileHandle, path) {
          super();
          this.fileHandle = fileHandle;
          this.path = path;
          this.materialId = undefined;
          while (this.materialId == undefined || materialIds.includes(this.materialId) || [Infinity, NaN].includes(Math.abs(this.materialId))) {
            this.materialId = Math.round(Math.random() * (1024 * Math.ceil(Math.max(1, ...srcIds) / 1024))) - 1;
          }
        }
      }

      class SourceBase extends Object {
        static check(file) {
          return false;
        }
        constructor(file, path, format, type=SOURCE_TYPES.UNKNOWN, options={}) {
          options = options
          super();
          this.id = undefined;
          while (this.id == undefined || srcIds.includes(this.id) || [Infinity, NaN].includes(Math.abs(this.id))) {
            this.id = Math.round(Math.random() * (1024 * Math.ceil(Math.max(1, ...srcIds) / 1024))) - 1;
          }
          srcIds.push(this.id);
          this.file = file;
          this.path = path;
          this.format = format;
          this.__type = type;
          let el = document.createElement("src-obj");
          el.setAttribute("type", SOURCE_TYPE_TEXTS[type]);
          el.setAttribute("name", this.file.name);
          el.srcObj = this;
          let detail = document.createElement("div");
          this.__el = el;
          this.__detail = detail;
          this.__preview = null;
          this.width = 0;
          this.height = 0;
          this.aspect = {begin:1, end:1};
          this.keepAspect = true;
          this.options = [
            new SourceOption({
              x: new OptionValue(0),
              y: new OptionValue(0),
              posOrigin: "top-left",
              posOriginRoot: "top-left",
              scale: new OptionValue(1),
              alpha: new OptionValue(0),
              rotate: new OptionValue(0),
              width: new OptionValue(this.width),
              height: new OptionValue(this.height),
              frames: [0, 1], //表示フレームのどの範囲か
              span: [0, 1], //もとのソースのフレームのどの範囲か
              timeScale: 1,
              length: 0,
              effects: []
            }, this.__el),
          ];
          this.setupDetail();
          for (let option of this.options) {
            option.addEventListener("change", (e)=>{
              if (e.key == "x") {
                this.__preview.style.left = "calc(var(--unit-px) * " + e.value.curValue + "px" + (e.target.posOriginRoot=="center"?" + 50%":"") + ")";
              } else if (e.key == "y") {
                this.__preview.style.top = "calc(var(--unit-px) * " + e.value.curValue + "px" + (e.target.posOriginRoot=="center"?" + 50%":"") + ")";
              } else if (e.key == "width") {
                this.__preview.style.width = (e.value.curValue || 0) + "px";
                if (!this.keepAspect) {
                  this.aspect.begin = e.value.curValue / e.target.height.begin;
                  this.aspect.end = e.value.end / e.target.height.end;
                }
              } else if (e.key == "height") {
                this.__preview.style.height = (e.value.curValue || 0) + "px";
                if (!this.keepAspect) {
                  this.aspect.begin = e.target.width.begin / e.value.begin;
                  this.aspect.end = e.target.width.end / e.value.end;
                }
              } else if (e.key == "rotate") {
                this.__preview.style.rotate = e.value.curValue + "deg";
              } else if (e.key == "alpha") {
                this.__preview.style.opacity = (1 - e.value.curValue) * 100 + "%";
              } else if (e.key == "span") {
                e.target.frames = [e.target.frames[0], e.target.frames[0] + Math.round((e.target.span[1] - e.target.span[0]) * e.target.timeScale)];
              } else if (e.key == "frames") {
                e.target.timeScale = (e.target.span[1] - e.target.span[0]) / (e.target.frames[1] - e.target.frames[0]);
              } else if (e.key == "posOrigin") {
                if (e.value == "top-left") {
                  this.__preview.style.translate = "";
                } else if (e.value == "center") {
                  this.__preview.style.translate = "-50% -50%";
                }
              } else if (e.key == "posOriginRoot") {
                e.target.x = e.target.x;
                e.target.y = e.target.y;
              }
            });
          }
        }
        get type() {
          return this.__type;
        }
        get sourceElement() {
          return this.__el;
        }
        get detailElement() {
          return this.__detail;
        }
        get previewElement() {
          return this.__preview;
        }
        hasAudio() {
          return false;
        }
        setupDetail() {
          let px = document.createElement("span");
          px.setAttribute("class", "px");
          px.innerText = "px";
          let percent = document.createElement("span");
          percent.setAttribute("class", "percent");
          percent.innerText = "%";
          let degree = document.createElement("span");
          degree.setAttribute("class", "degree");
          degree.innerText = "度";
          let ms = document.createElement("span");
          ms.setAttribute("class", "ms");
          ms.innerText = "ms";

          let div = document.createElement("div");
          let label = document.createElement("label");
          label.innerText = "ソースの範囲";
          let span = [
            document.createElement("input"),
            document.createElement("input")
          ];
          span[0].setAttribute("class", "span-start");
          span[1].setAttribute("class", "span-end");
          div.append(label, span[0], ms.cloneNode(1), span[1], ms.cloneNode(1));
          this.__detail.appendChild(div);

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "表示する期間";
          let frames = [
            document.createElement("input"),
            document.createElement("input")
          ];
          frames[0].setAttribute("class", "frames-start");
          frames[1].setAttribute("class", "frames-end");
          div.append(label, frames[0], ms.cloneNode(1), frames[1], ms.cloneNode(1));
          this.__detail.appendChild(div);

          let poses = document.createElement("div");
          poses.setAttribute("class", "first");

          let xy = document.createElement("div");
          xy.setAttribute("class", "xy");
          poses.appendChild(xy);

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "x座標";
          label.setAttribute("for", "posx");
          let posX = document.createElement("transitional-input");
          posX.setAttribute("name", "posx");
          posX.setAttribute("type", "number");
          div.append(label, posX);
          xy.appendChild(div);

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "y座標";
          label.setAttribute("for", "posy");
          let posY = document.createElement("transitional-input");
          posY.setAttribute("name", "posy");
          posY.setAttribute("type", "number");
          div.append(label, posY);
          xy.appendChild(div);

          div = document.createElement("div");
          let origin = document.createElement("select");
          let originRoot = document.createElement("select");
          label = document.createElement("label");
          label.innerText = "座標の位置";
          let label2 = document.createElement("label");
          label2.innerText = "から";
          origin.setAttribute("name", "origin");
          origin.append(...[["top-left", "要素の左上"], ["center","要素の中心"]].map((text)=>{
            let el = document.createElement("option");
            el.setAttribute("value", text[0]);
            el.innerText = text[1];
            if (text[0] == "top-left") {
              el.setAttribute("selected", "");
            }
            return el;
          }));
          originRoot.setAttribute("name", "origin-root");
          originRoot.append(...[["top-left", "画面の左上"], ["center","画面の中心"]].map((text)=>{
            let el = document.createElement("option");
            el.setAttribute("value", text[0]);
            el.innerText = text[1];
            if (text[0] == "top-left") {
              el.setAttribute("selected", "");
            }
            return el;
          }));
          div.append(label, originRoot, label2, origin);
          let div2 = document.createElement("div");
          div2.appendChild(div);
          poses.appendChild(div2);
          this.__detail.append(poses);


          let sizes = document.createElement("div");
          sizes.setAttribute("class", "first");

          let size = document.createElement("div");
          size.setAttribute("class", "size");


          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "横幅";
          label.setAttribute("for", "width");
          let inputs = document.createElement("div");
          inputs.setAttribute("class", "inputs");
          let width = [document.createElement("transitional-input"), document.createElement("transitional-input")];
          width[0].setAttribute("name", "width");
          width[0].setAttribute("type", "number");
          width[1].setAttribute("name", "widthp");
          width[1].setAttribute("type", "number");
          inputs.append(width[0], px.cloneNode(1), width[1], percent.cloneNode(1))
          div.append(label, inputs);
          size.appendChild(div);

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "高さ";
          label.setAttribute("for", "height");
          inputs = document.createElement("div");
          inputs.setAttribute("class", "inputs");
          let height = [document.createElement("transitional-input"), document.createElement("transitional-input")];
          height[0].setAttribute("name", "height");
          height[0].setAttribute("type", "number");
          height[1].setAttribute("name", "heightp");
          height[1].setAttribute("type", "number");
          inputs.append(height[0], px.cloneNode(1), height[1], percent.cloneNode(1))
          div.append(label, inputs);
          size.appendChild(div);
          sizes.append(size);

          let aspectLock = document.createElement("input");
          aspectLock.setAttribute("type", "checkbox");
          aspectLock.setAttribute("name", "aspect-lock");
          aspectLock.setAttribute("checked", "");
          sizes.appendChild(aspectLock);
          this.__detail.append(sizes);

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "回転";
          label.setAttribute("for", "rotate");
          let rotate = document.createElement("transitional-input");
          rotate.setAttribute("name", "rotate");
          rotate.setAttribute("type", "number");
          div.append(label, rotate, degree.cloneNode(1));
          this.__detail.appendChild(div);

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "透明度";
          label.setAttribute("for", "alpha");
          let alpha = document.createElement("transitional-input");
          alpha.setAttribute("name", "alpha");
          alpha.setAttribute("type", "number");
          div.append(label, alpha, percent.cloneNode(1));
          this.__detail.appendChild(div);

          span[0].addEventListener("change", (e)=>{let value = Math.max(0, Math.round(e.target.value * main.fps.video)); this.options[0].span = [value, this.options[0].span[1] - this.options[0].span[0] + value];});
          span[1].addEventListener("change", (e)=>{let value = Math.max(0, Math.round(e.target.value * main.fps.video)); this.options[0].span = [Math.min(value, this.options[0].span[0]), value];});
          frames[0].addEventListener("change", (e)=>{let value = Math.max(0, Math.round(e.target.value * main.fps.video)); this.options[0].frames = [value, this.options[0].frames[1] - this.options[0].frames[0] + value];let layer=main.layers.findIndex((layer)=>layer.indexOf(this)>=0);if(layer>=0){let index=main.layers[layer].indexOf(this);main.pushSrcAt(layer, index, this);main.removeSrcAt(layer, index);}});
          frames[1].addEventListener("change", (e)=>{let value = Math.max(0, Math.round(e.target.value * main.fps.video)); this.options[0].frames = [Math.min(value, this.options[0].frames[0]), value];let layer=main.layers.findIndex((layer)=>layer.indexOf(this)>=0);if(layer>=0){let index=main.layers[layer].indexOf(this);main.pushSrcAt(layer, index, this);main.removeSrcAt(layer, index);}});

          posX.begin.addEventListener("change", (e)=>{this.options[0].x.begin = Math.round(parseFloat(e.target.value || 0) * 100) / 100;});
          posX.end.addEventListener("change", (e)=>{this.options[0].x.end = Math.round(parseFloat(e.target.value || 0) * 100) / 100;});
          posY.begin.addEventListener("change", (e)=>{this.options[0].y.begin = Math.round(parseFloat(e.target.value || 0) * 100) / 100;});
          posY.end.addEventListener("change", (e)=>{this.options[0].y.end = Math.round(parseFloat(e.target.value || 0) * 100) / 100;});
          origin.addEventListener("change", (e)=>{this.options[0].posOrigin = e.target.value;});
          originRoot.addEventListener("change", (e)=>{this.options[0].posOriginRoot = e.target.value;});
          width[0].begin.addEventListener("change", (e)=>{this.options[0].width.begin = Math.round(parseFloat(e.target.value || 0) * 100) / 100;if(this.keepAspect){this.options[0].height.begin = this.options[0].width.begin / this.aspect.begin;}});
          width[0].end.addEventListener("change", (e)=>{this.options[0].width.end = Math.round(parseFloat(e.target.value || 0) * 100) / 100;if(this.keepAspect){this.options[0].height.end = this.options[0].width.end / this.aspect.end;}});
          height[0].begin.addEventListener("change", (e)=>{this.options[0].height.begin = Math.round(parseFloat(e.target.value || 0) * 100) / 100;if(this.keepAspect){this.options[0].width.begin = this.options[0].height.begin * this.aspect.begin;}});
          height[0].end.addEventListener("change", (e)=>{this.options[0].height.end = Math.round(parseFloat(e.target.value || 0) * 100) / 100;if(this.keepAspect){this.options[0].width.end = this.options[0].height.end * this.aspect.end;}});
          width[1].begin.addEventListener("change", (e)=>{this.options[0].width.begin = Math.round(this.width * parseFloat(e.target.value || 0)) / 100;if(this.keepAspect){this.options[0].height.begin = this.options[0].width.begin / this.aspect.begin;}});
          width[1].end.addEventListener("change", (e)=>{this.options[0].width.end = Math.round(this.width * parseFloat(e.target.value || 0)) / 100;if(this.keepAspect){this.options[0].height.end = this.options[0].width.end / this.aspect.end;}});
          height[1].begin.addEventListener("change", (e)=>{this.options[0].height.begin =  Math.round(this.height * parseFloat(e.target.value || 0)) / 100;if(this.keepAspect){this.options[0].width.begin = this.options[0].height.begin * this.aspect.begin;}});
          height[1].end.addEventListener("change", (e)=>{this.options[0].height.end =  Math.round(this.height * parseFloat(e.target.value || 0)) / 100;if(this.keepAspect){this.options[0].width.end = this.options[0].height.end * this.aspect.end;}});
          rotate.begin.addEventListener("change", (e)=>{this.options[0].rotate.begin = Math.round(parseFloat(e.target.value || 0) * 100) / 100;});
          rotate.end.addEventListener("change", (e)=>{this.options[0].rotate.end = Math.round(parseFloat(e.target.value || 0) * 100) / 100;});
          alpha.begin.addEventListener("change", (e)=>{this.options[0].alpha.begin = Math.round(parseFloat(e.target.value || 0) * 100) / 10000;});
          alpha.end.addEventListener("change", (e)=>{this.options[0].alpha.end = Math.round(parseFloat(e.target.value || 0) * 100) / 10000;});
          aspectLock.addEventListener("change", (e)=>{this.keepAspect = e.target.checked;});

          this.options[0].addEventListener("change", (e)=>{
            if (e.key == "x") {
              posX.begin.value = e.value.begin;
              posX.end.value = e.value.end;
            } else if (e.key == "y") {
              posY.begin.value = e.value.begin;
              posY.end.value = e.value.end;
            } else if (e.key == "width") {
              width[0].begin.value = this.options[0].width.begin;
              width[0].end.value = this.options[0].width.end;
              width[1].begin.value = this.width? Math.round(10000 * this.options[0].width.begin / this.width) / 100: 100;
              width[1].end.value = this.width? Math.round(10000 * this.options[0].width.end / this.width) / 100: 100;
            } else if (e.key == "height") {
              height[0].begin.value = this.options[0].height.begin;
              height[0].end.value = this.options[0].height.end;
              height[1].begin.value = this.height? Math.round(10000 * this.options[0].height.begin / this.height) / 100 : 100;
              height[1].end.value = this.height? Math.round(10000 * this.options[0].height.end / this.height) / 100 : 100;
            } else if (e.key == "alpha") {
              alpha.begin.value = Math.round(e.value.begin * 10000) / 100;
              alpha.end.value = Math.round(e.value.end * 10000) / 100;
            } else if (e.key == "span") {
              span[0].value = Math.round(e.value[0] / main.fps.video);
              span[1].value = Math.round(e.value[1] / main.fps.video);
            } else if (e.key == "frames") {
              frames[0].value = Math.round(e.value[0] / main.fps.video);
              frames[1].value = Math.round(e.value[1] / main.fps.video);
            }
          });
          this.options[0].redraw();
        }
        async decodeReady() {
        }
        async getFrame(frame) {
        }
        async decodeCleanup() {
        }
        delete() {
          try {
            this.__el.srcObj = undefined;
          } catch {}
          try {
            this.__el.remove();
          } catch {}
          try {
            this.__detail.remove();
          } catch {}
          try {
            this.__preview.remove();
          } catch {}
        }
        static async getSourceFromFileHandle(fileHandle) {
          if (!FileSystemFileHandle.prototype.isPrototypeOf(fileHandle)) {
            throw "given fileHandle is not a FileSystemFileHandle instance";
            return;
          }
          console.log(fileHandle.name);
          let file = await fileHandle.getFile();
          let path = (await main.dir.resolve(fileHandle)).join("/");
          const format = file.name.match(/(?:(?<=\.)[a-zA-Z0-9]*)?$/)[0].toLowerCase();
          return new this(file, path, format);
        }
        static getSourceFromFileHandles(fileHandleList) {
          let promises = [];
          for (let fileHandle of fileHandleList) {
            promises.push(this.getSourceFromFileHandle(fileHandle));
          }
          return Promise.allSettled(promises);
        }
        static getSourceFromArrayBuffer(arrayBuffer) {
          console.log(arrayBuffer);
          return arrayBuffer;
        }
      }

      class MP4Box extends Object {
        constructor(type, is_parent=undefined) {
          super();
          this.type = type;
          if (['cmov', 'ctts', 'dinf', 'edts', 'esds', 'free', 'ftyp', 'iods', 'junk', 'mdia', 'minf', 'moov', 'mvhd', 'pict', 'pnot', 'rmda', 'rmra', 'skip', 'stbl', 'trak', 'uuid', 'wide'].includes(type)) {
            this.isParent = true;
          } else {
            if (!['ctab', 'co64', 'dref', 'fiel', 'mdat', 'rdrf', 'rmcd', 'rmcs', 'rmdr', 'rmqu', 'rmvc', 'wfex', 'cmvd', 'co64', 'dcom', 'elst', 'gmhd', 'hdlr', 'mdhd', 'smhd', 'stco', 'stsc', 'stsd', 'stss', 'stsz', 'stts', 'tkhd', 'tname', 'udta', 'vmhd'].includes(type)) {
              console.warn("unexpected box type: " + type);
              this.isParent = false;
            } else {
              this.isParent = false;
            }
          }
          if (is_parent != undefined) {
            this.isParent = is_parent;
          }
          this.child = undefined;
        }
        getLength() {
          var size;
          if (this.child == undefined) {
            size = 0n;
          } else if (this.isParent && Array.prototype.isPrototypeOf(this.child) && this.child.every((ch)=>(MP4Box.prototype.isPrototypeOf(ch) || Uint8Array.prototype.isPrototypeOf(ch)), true)) {
            size = this.child.reduce((total, ch)=>total+(MP4Box.prototype.isPrototypeOf(ch)?ch.getLength():BigInt(ch.length)), 0n);
          } else if (Uint8Array.prototype.isPrototypeOf(this.child)) {
            size = BigInt(this.child.length);
          } else {
            throw "unexpected child type: " + this.child;
          }
          size += 8n;
          if (size > 0xffffffffffn) {
            size += 8n;
          }
          return size;
        }
        getBinary() {
          var binValue;
          var result;
          var size = 0;
          if (this.child == undefined) {
            binValue = new Uint8Array(0);
          } else if (this.isParent && Array.prototype.isPrototypeOf(this.child) && this.child.every((ch)=>(MP4Box.prototype.isPrototypeOf(ch) || Uint8Array.prototype.isPrototypeOf(ch)), true)) {
            binValue = new Uint8Array(this.child.reduce((total, ch)=>[...total, ...(MP4Box.prototype.isPrototypeOf(ch)?ch.getBinary():ch)], []));
          } else if (Uint8Array.prototype.isPrototypeOf(this.child)) {
            binValue = this.child;
          } else {
            throw "unexpected child type: "+this.child;
          }
          size = BigInt(binValue.length) + 8n;
          if (size > 0xffffffff) {
            result.set([0, 0, 0, 1], 0);
            result = new Uint8Array(parseInt(size + 8n));
            result.set([
              size >> 256n,
              (size & 0xff000000000000n) >> 128n,
              (size & 0xff0000000000n) >> 64n,
              (size & 0xff00000000n) >> 32n,
              (size & 0xff000000n) >> 24n,
              (size & 0xff0000n) >> 16n,
              (size & 0xff00n) >> 8n,
              size & 0xffn
            ].map((i)=>parseInt(i)), 8);
            result.set(binValue, 16);
          } else {
            result = new Uint8Array(parseInt(size));
            result.set([
              size >> 24n,
              (size & 0xff0000n) >> 16n,
              (size & 0xff00n) >> 8n,
              size & 0xffn
            ].map((i)=>parseInt(i)), 0);
            result.set(binValue, 8);
          }
          result.set([...this.type].map((ch)=>ch.charCodeAt(0)), 4);
          return result;
        }
      }

      class MultipleAudioBuffersSourceNode extends AudioBufferSourceNode {
        constructor(context, buffers, options={}) {
          super(context, {...options, buffer: null});
          /*this.outputNode = new GainNode(context, {
            gain: 1,
            channelCount: options.channelCount,
            channelCountMode: options.channelCountMode,
            channelInterpretation: options.channelInterpretation
          });*/
          this.buffers = [];
          this.sourceNodes = [];
          for (let buffer of buffers) {
            let node = new AudioBufferSourceNode(context, {
              ...options,
              buffer: buffer,
            });
            //node.connect(this.outputNode);
            this.sourceNodes.push(node);
            this.buffers.push(buffer);
          }

          //this.connect = this.outputNode.connect.bind(this);
          //this.disconnect = this.outputNode.disconnect.bind(this);

          this._currentNode = undefined;
          this._startTime = undefined
        }

        connect(...args) {
          this.sourceNodes.forEach((node)=>node.connect(...args));
        }

        disconnect(...args) {
          this.sourceNodes.forEach((node)=>node.disconnect(...args));
        }

        get currentNode() {
          if (this._startTime != undefined) {
            var timeOffset = 0;
          }
        }

        start(when, offset, duration) {
          console.log("start:", when, offset, duration);
          this._currentNode = undefined;
          var timeOffset = 0;
          for (let node of this.sourceNodes) {
            if (offset < timeOffset + node.buffer.duration) {
              if (duration - timeOffset < 0) {
                break;
              }
              if (this._currentNode == undefined) {
                this._currentNode = node;
              }
              console.log("node.start(", when+timeOffset, Math.max(0, timeOffset + node.buffer.duration - offset), duration-timeOffset, ")")
              node.start(when+timeOffset, Math.max(0,  offset - timeOffset + node.buffer.duration), duration-timeOffset);
            }
            timeOffset += node.buffer.duration;
          }
        }

        stop(when) {
          console.log("stop: ", when);
          for (let node of this.nodes) {
            if (offset < timeOffset + node.buffer.duration) {
              node.stop(when);
            }
          }
        }
      }

      class VideoSource extends SourceBase {
        static SUPPORTED = ["mp4",];
        static check(file) {
          return file.type.startsWith("video/");
        }
        constructor(file, path, arrayBuffer, format="mp4") {
          super(file, path, format, SOURCE_TYPES.VIDEO);
          this.arrayBuffer = arrayBuffer;
          this.options.forEach((option)=>{
            let addition = {
              volume: 1
            };
            for (let key of Object.keys(addition)) {
              option.addKey(key, addition[key]);
            }
            option.addEventListener("change", (e)=>{
              if (e.key == "timeScale") {
                this.__preview.playbackRate = isFinite(e.value)?e.value:1.0;
              } else if (e.key == "volume") {
                this.__preview.volume = e.value;
              }
            });
          });
          this.__preview = document.createElement("video");
          this.__curChunk = 0;
          this.options[0].width.begin = this.options[0].width.end = undefined;
          this.options[0].height.begin = this.options[0].height.end = undefined;
          this.__preview.addEventListener("loadedmetadata", (e)=>{
            this.aspect = {begin:this.__preview.videoWidth / this.__preview.videoHeight, end:this.__preview.videoWidth / this.__preview.videoHeight};
            this.width = this.__preview.videoWidth;
            this.height = this.__preview.videoHeight;
            if (this.options[0].width == undefined || this.options[0].height == undefined) {
              this.options[0].width.begin = this.options[0].width.end = this.width;
              this.options[0].height.begin = this.options[0].height.end = this.height;
            }
          });
          if (!main.demo) {
            this.__preview.src = URL.createObjectURL(file);
          } else {
            this.__preview.src = new URL(path, main.dir);
          }
          let tracks = [];
          if (!this.constructor.SUPPORTED.includes(this.format)) {
            throw "given video format is not supported";
          } else if (this.format == "mp4") {
            let leaf_list = ['ctab', 'co64', 'fiel', 'mdat', 'rdrf', 'rmcd', 'rmcs', 'rmdr', 'rmqu', 'rmvc', 'wfex', 'cmvd', 'co64', 'dcom', 'elst', 'gmhd', 'hdlr', 'mdhd', 'smhd', 'stco', 'stsc', 'stsd', 'stss', 'stsz', 'stts', 'tkhd', 'tname', 'udta', 'vmhd'];
            let parent_list = ['cmov', 'ctts', 'dinf', 'edts', 'esds', 'free', 'ftyp', 'iods', 'junk', 'mdia', 'minf', 'moov', 'mvhd', 'pict', 'pnot', 'rmda', 'rmra', 'skip', 'stbl', 'trak', 'uuid', 'wide'];
            const array = new Uint8Array(arrayBuffer);
            let i = 0;
            let indexes = [[0, array.length], [-1, 0],];
            let deep = 0;
            let text = "";
            let track;
            while (i < array.length) {
              indexes.at(-1)[0] += 1;
              let start = i;
              let len = array.slice(i, i+4).reduce((total, i)=>total*256+i,0);
              i += 4;
              let type = array.slice(i, i+4).reduce((total, i)=>total+String.fromCharCode(i),"");
              i += 4;
              if (len == 1) {
                len = array.slice(i, i+8).reduce((total, i)=>total*256+i,0);
                i += 8;
              }
              indexes.at(-1)[1] += len;
              let isLeaf = leaf_list.includes(type);
              if (!isLeaf) {
                var nextType = array.slice(i+4, i+8).reduce((total, i)=>total+String.fromCharCode(i),"");
                isLeaf = !leaf_list.includes(nextType) && !parent_list.includes(nextType);
              }
              if (type=="trak") {
                track = {
                  timestamp: 0,
                  timeScale: 1,
                  colorSpace: new VideoColorSpace(),
                  hardwareAcceleration: "prefer-software",
                  optimizeForLatency: true
                };
                tracks.push(track);
              }
              /*if (type == "tkhd") {
                switch (array.slice(i+(1+3+4*5+8+2), i+(1+3+4*5+8+2+2)).reduce((total, i)=>total*256+i, 0)) {
                  case 0:
                    track.type = 'video';
                    break;
                  case 1:
                    track.type = 'audio';
                    break;
                  case 2:
                    track.type = 'subtitle';
                    break;
                }
                if (!track.width || !track.height) {
                  track.width = array.slice(i+(1+3+4*5+8+2*4+36), i+(1+3+4*5+8+2*4+36+4-2)).reduce((total, i)=>total*256+i, 0) + array.slice(i+(1+3+4*5+8+2*4+36+4-2), i+(1+3+4*5+8+2*4+36+4)).reverse().reduce((total, i)=>total/256+i.toString(2).padStart(8, "0").match(/./g).reverse().reduce((total, i)=>total/2 + i/2, 0), 0);
                  track.height = array.slice(i+(1+3+4*5+8+2*4+36+4), i+(1+3+4*5+8+2*4+36+4+4-2)).reduce((total, i)=>total*256+i, 0) + array.slice(i+(1+3+4*5+8+2*4+36+4+4-2), i+(1+3+4*5+8+2*4+36+4+4)).reverse().reduce((total, i)=>total/256+i.toString(2).padStart(8, "0").match(/./g).reverse().reduce((total, i)=>total/2 + i/2, 0), 0);
                }
              }*/
              if (type == "hdlr") {
                switch (String.fromCharCode(...array.slice(i+(1+3+4), i+(1+3+8)))) {
                  case "vide":
                    track.type = "video";
                    break;
                  case "soun":
                    track.type = "sound";
                    break;
                  default:
                    ;
                    //throw "Unknown track type";
                }
                console.log(String.fromCharCode(...array.slice(i+(1+3+20), start+len)));
              }
              if (type == "mdhd") {
                track.timeScale = array.slice(i+(1+3+4*2), i+(1+3+4*3)).reduce((total, i)=>total*256+i, 0)/1000;
                track.duration = array.slice(i+(1+3+4*3), i+(1+3+4*4)).reduce((total, i)=>total*256+i, 0);
              }
              if (type == "stsd") {
                let entrylen = array.slice(i+(1+3), i+(1+3+4)).reduce((total, i)=>total*256+i);
                let index = 0;
                track.sampleDescriptions = [];
                for (let entry=0; entry < entrylen; entry++) {
                  let size = array.slice(i+(1+3+4 + index), i+(1+3+4+index+4)).reduce((total, i)=>total*256+i, 0);
                  index += 4;
                  if (size == 0) {
                    continue;
                  }
                  let codec = array.slice(i+(1+3+4+index), i+(1+3+4+index+4)).reduce((total, i)=>total+String.fromCharCode(i), "")
                  let description = {
                    codec: codec,
                    referenceIndex: array.slice(i+(1+3+4+10+index), i+(1+3+4+10+index+2)).reduce((total, i)=>total*256+i, 0),
                  };
                  if (codec == "mp4a") {
                    description.version = array.slice(i+(1+3+4+12+index), i+(1+3+4+12+index+2)).reduce((total, i)=>total*256+i, 0);
                    console.log("mp42 version", description.version);
                    if (description.version == 0) {
                      description.channels = array.slice(i+(1+3+4+20+index), i+(1+3+4+20+index+2)).reduce((total, i)=>total*256+i, 0);
                      index += 32;
                    } else if (description.version == 1) {
                      description.channels = array.slice(i+(1+3+4+20+index), i+(1+3+4+20+index+2)).reduce((total, i)=>total*256+i, 0);
                      index += 48;
                    } else {
                      description.channels = array.slice(i+(1+3+4+36+index), i+(1+3+4+36+index+4)).reduce((total, i)=>total*256+i, 0);
                      index += 60;
                    }
                  } else if (["mp4v", "avc1"].includes(codec)) {
                    index += 82;
                  } else {
                    index += 12;
                  }
                  if (["mp4v", "mp4a", "avc1"].includes(codec)) {
                    var i2 = 1+3+4;
                    while (i2+index < size) {
                      let start = i2;
                      let len = array.slice(i+index+i2, i+index+i2+4).reduce((total, i)=>total*256+i,0);
                      i2 += 4;
                      let type = array.slice(i+index+i2, i+index+i2+4).reduce((total, i)=>total+String.fromCharCode(i),"");
                      console.log(type);
                      if (type == "\0\0\0\0") {
                        break;
                      }
                      i2 += 4;
                      if (len == 1) {
                        let len = array.slice(i+index+i2, i+index+i2+8).reduce((total, i)=>total*256+i,0);
                        i2 += 8;
                      }
                      if (type == "avcC") {
                        description.AVCDecoderConfigurationRecord = array.slice(i+index+i2, i+index+start+len);
                      }
                      if (type == "colr") {
                        console.log(array.slice(i+index+i2, i+index+start+len));
                      }
                      if (type == "esds") {
                        description.elementaryStreamDescriptor = array.slice(i+index+i2+4, i+index+start+len);
                      }
                      i2 = start + len;
                    }
                  }
                  track.sampleDescriptions.push(description);
                }
              }
              if (type == "stts") { // Time-to-Sample
                track.timeToSample = [];
                let entrylen = array.slice(i+(1+3), i+(1+3+4)).reduce((total, i)=>total*256+i);
                let index = 0;
                for (let entry=0; entry < entrylen; entry++) {
                  track.timeToSample.push({
                    count: array.slice(i+(1+3+4 + index), i+(1+3+4+index+4)).reduce((total, i)=>total*256+i, 0),
                    duration: array.slice(i+(1+3+4 + index+4), i+(1+3+4+index+8)).reduce((total, i)=>total*256+i, 0)
                  });
                  index += 8;
                }
              }
              if (type == "stsc") { // Sample-to-Chunk
                track.sampleToChunk = [];
                let entrylen = array.slice(i+(1+3), i+(1+3+4)).reduce((total, i)=>total*256+i, 0);
                let index = 0;
                console.log(entrylen);
                for (let entry=0; entry < entrylen; entry++) {
                  track.sampleToChunk.push({
                    first: array.slice(i+(1+3+4 + index), i+(1+3+4+index+4)).reduce((total, i)=>total*256+i, 0),
                    samplesPerChunk: array.slice(i+(1+3+4 + index+4), i+(1+3+4+index+8)).reduce((total, i)=>total*256+i, 0),
                    descriptionId: array.slice(i+(1+3+4 + index+8), i+(1+3+4+index+12)).reduce((total, i)=>total*256+i, 0)
                  });
                  index += 12;
                }
              }
              if (type == "stss") { // Sync Sample
                track.syncSample = [];
                let entrylen = array.slice(i+(1+3), i+(1+3+4)).reduce((total, i)=>total*256+i);
                let index = 0;
                for (let entry=0; entry < entrylen; entry++) {
                  track.syncSample.push(array.slice(i+(1+3+4 + index), i+(1+3+4+index+4)).reduce((total, i)=>total*256+i, 0));
                  index += 4;
                }
              }
              if (type == "stsz") { // Sample Size
                track.sampleSize = [];
                let index = 0;
                let size = array.slice(i+(1+3), i+(1+3+4)).reduce((total, i)=>total*256+i, 0);
                let entrylen = array.slice(i+(1+3+4), i+(1+3+4*2)).reduce((total, i)=>total*256+i);
                console.log([size, entrylen]);
                if (size > 0) {
                  for (let entry=0; entry < entrylen; entry++) {
                    track.sampleSize.push(size);
                  }
                } else {
                  for (let entry=0; entry < entrylen; entry++) {
                    track.sampleSize.push(array.slice(i+(1+3+4*2 + index), i+(1+3+4*2+index+4)).reduce((total, i)=>total*256+i, 0));
                    index += 4;
                  }
                }
              }
              if (type == "stco") { // Chunk Offset
                track.chunkOffset = [];
                let entrylen = array.slice(i+(1+3), i+(1+3+4)).reduce((total, i)=>total*256+i);
                let index = 0;
                for (let entry=0; entry < entrylen; entry++) {
                  track.chunkOffset.push(array.slice(i+(1+3+4 + index), i+(1+3+4+index+4)).reduce((total, i)=>total*256+i, 0));
                  index += 4;
                }
              }
              if (type == "co64") { // Chunk Offset 64bits
                track.chunkOffset = [];
                let entrylen = array.slice(i+(1+3), i+(1+3+4)).reduce((total, i)=>total*256+i);
                let index = 0;
                for (let entry=0; entry < entrylen; entry++) {
                  track.chunkOffset.push(array.slice(i+(1+3+4 + index), i+(1+3+4+index+8)).reduce((total, i)=>total*256+i, 0));
                  index += 8;
                }
              }
              if (isLeaf) {
                text = text + "  ".repeat(deep)+" "+type+" - "+len + "\n";
                while (indexes.length > 1 && indexes.at(-2)[1] <= start+len) {
                  deep -= 1;
                  indexes.pop();
                }
                i = start + len;
              } else {
                text = text + "  ".repeat(deep)+" "+type+" - "+len + "\n";
                deep += 1;
                indexes.push([-1, i]);
              }
              if (indexes.length == 0) {
                break;
              }
            }
            console.log(text);
          }
          console.log(tracks);
          this.tracks = tracks;
          this.options[0].span = this.options[0].frames = [0, Math.ceil(main.fps.video * ((track)=>track.duration/track.timeScale)(tracks.find((track)=>track.type=="video")))];
          this.__preview.load();
        }
        hasAudio() {
          return this.tracks.some((track)=>track.type == "sound");
        }
        async decodeReady(context) {
          this.decoders = {video: undefined, audio: undefined};
          this.frames = {video: []};
          this.audioDatas = [];
          this.decodedFrame = {video: 0, audio: 0};
          for (let track of this.tracks) {
            if (track.type == "video") {
              try {
                track.description = track.sampleDescriptions.find((value)=>["mp4v", "avc1", "av01"].includes(value.codec));
                if (track.description == undefined) { continue; }
                track.codec = track.description.codec;
                console.log(track.codec);
              } catch { continue; }
              if (["mp4a", "mp4v"].includes(track.codec)) {
                track.codec = track.codec + ".oo.V";
              } else if (track.codec == "avc1") {
                ;
              } else if (track.codec == "av01") {
                track.codec = "av01.0.15M.10";
              }
              track.chunks = [];
              if (track.sampleSize.length == 1) {
                let sampleSize = track.sampleSize[0];
                track.sampleSize = [];
                let entrylen = track.timeToSample.reduce((total, i)=>total+i.count, 0);
                for (let entry=0; entry < entrylen; entry++) {
                  track.sampleSize.push(sampleSize);
                }
              }
              let timestamp = track.timestamp;
              for (let i=0; i < track.chunkOffset.length; i++) {
                let samplePos = [0, 0];
                let durations = [];
                for (let index = 0; index < i+1; index++) {
                  let len = track.sampleToChunk.reduce((total, i)=>total*(i.first > index+1)+i.samplesPerChunk*(i.first <= index+1), 0);
                  samplePos[0] += len;
                  samplePos[1] = len;
                }
                samplePos[0] -= samplePos[1]
                let samplelen = 0;
                for (let index = 0; index < track.timeToSample.length; index++) {
                  //console.log(track.timeToSample.at(index));
                  for (let sample = Math.max(samplelen, samplePos[0]); sample < samplePos[0]+samplePos[1]; sample++) {
                    durations.push(track.timeToSample.at(index).duration);
                  }
                  samplelen += track.timeToSample.at(index).count;
                }
                //let len = new Uint8Array(this.arrayBuffer.slice(track.chunkOffset[i], track.chunkOffset[i]+4)).reduce((total, i)=>total*256+i, 0);
                if (i == 0) {console.log(samplePos)}
                let sizes = track.sampleSize.slice(samplePos[0], samplePos[0]+samplePos[1]);
                let len = sizes.reduce((total, i)=>total+i, 0);
                //console.log(samplePos);
                let offset = 0;
                let sample = samplePos[0]+1;
                for (let size of sizes) {
                  track.chunks.push(new EncodedVideoChunk({
                    type: ["delta","key"].at(track.syncSample.includes(sample) || track.chunks.length == 0),
                    data: this.arrayBuffer.slice(track.chunkOffset[i]+offset, track.chunkOffset[i]+offset+size),
                    timestamp: Math.floor(timestamp * 1000 / track.timeScale),
                    duration: Math.floor(durations[0] * 1000 / track.timeScale)
                  }));
                  timestamp += durations.splice(0, 1)[0] / track.timeScale;
                  sample += 1;
                  offset += size;
                }
                // Math.ceil(1000 * track.duration / track.timeScale)
              }
              let decoder = new VideoDecoder({output:(frame)=>{this.frames.video.push(frame);}, error:(e)=>{throw e;}});
              console.log(track.codec);
              let config = {
                codec: track.codec,
                colorSpace: track.colorSpace,
                hardwareAcceleration:track.hardwareAcceleration,
                optimizeForLatency:track.optimizeForLatency
              };
              if (track.description.codec == "avc1") {
                console.log(track.description.AVCDecoderConfigurationRecord)
                config.description = track.description.AVCDecoderConfigurationRecord;
                config.codec = "avc1."+config.description[1].toString(16).padStart(2, "0")+config.description[2].toString(16).padStart(2, "0")+config.description[3].toString(16).padStart(2, "0")
              }
              decoder.configure(config);
              this.decoders.video = decoder;
              /* setTimeout(()=>{console.log(this);}, 100);
              for (let chunk of track.chunks) {
                decoder.decode(chunk);
                this.chunks.push(chunk);
              } */
            } else if (track.type == "sound") {
              try {
                track.description = track.sampleDescriptions.find((value)=>["mp4a"].includes(value.codec));
                track.codec = track.description.codec;
                console.log(track.codec);
              } catch { continue; }
              if (["mp4a"].includes(track.codec)) {
                track.codec += ".40";
              }
              track.chunks = [];
              if (track.sampleSize.length == 1) {
                let sampleSize = track.sampleSize[0];
                track.sampleSize = [];
                let entrylen = track.timeToSample.reduce((total, i)=>total+i.count, 0);
                for (let entry=0; entry < entrylen; entry++) {
                  track.sampleSize.push(sampleSize);
                }
              }
              let timestamp = track.timestamp;
              for (let i=0; i < track.chunkOffset.length; i++) {
                let samplePos = [0, 0];
                let durations = [];
                for (let index = 0; index < i+1; index++) {
                  let len = track.sampleToChunk.reduce((total, i)=>total*(i.first > index+1)+i.samplesPerChunk*(i.first <= index+1), 0);
                  samplePos[0] += len;
                  samplePos[1] = len;
                }
                samplePos[0] -= samplePos[1]
                let samplelen = 0;
                for (let index = 0; index < track.timeToSample.length; index++) {
                  //console.log(track.timeToSample.at(index));
                  for (let sample = Math.max(samplelen, samplePos[0]); sample < samplePos[0]+samplePos[1]; sample++) {
                    durations.push(track.timeToSample.at(index).duration);
                  }
                  samplelen += track.timeToSample.at(index).count;
                }
                //let len = new Uint8Array(this.arrayBuffer.slice(track.chunkOffset[i], track.chunkOffset[i]+4)).reduce((total, i)=>total*256+i, 0);
                if (i == 0) {console.log(samplePos)}
                let sizes = track.sampleSize.slice(samplePos[0], samplePos[0]+samplePos[1]);
                let len = sizes.reduce((total, i)=>total+i, 0);
                //console.log(samplePos);
                let offset = 0;
                let sample = samplePos[0]+1;
                for (let size of sizes) {
                  track.chunks.push(new EncodedAudioChunk({
                    type: "key",
                    data: this.arrayBuffer.slice(track.chunkOffset[i]+offset, track.chunkOffset[i]+offset+size),
                    timestamp: Math.floor(timestamp * 1000 / track.timeScale),
                    duration: Math.floor(durations[0] * 1000 / track.timeScale)
                  }));
                  timestamp += durations.splice(0, 1)[0] / track.timeScale;
                  sample += 1;
                  offset += size;
                }
                // Math.ceil(1000 * track.duration / track.timeScale)
              }
              let decoder = new AudioDecoder({output:(audiodata)=>{this.audioDatas.push(audiodata);}, error:(e)=>{throw e;}});
              let config = {
                codec: track.codec,
                sampleRate: track.timeScale * 1000,
                numberOfChannels: track.description.channels || 1,
                hardwareAcceleration:track.hardwareAcceleration,
                optimizeForLatency:track.optimizeForLatency,
              };
              if (track.description.elementaryStreamDescriptor != undefined) {
                let description = track.description.elementaryStreamDescriptor;
                var index = 0;
                if (description[index] == 3) {
                  index += 4;
                  index += 2 * (description[index] >>> 5);
                  index += 1;
                  if (description[index] == 4) {
                    index += 2;
                    if (description[index] == 0x40 && (description[index+1] >>> 2) == 0x05) {
                      // AAC
                      index += 2 + 3 + 4 + 4;
                      if (description[index] == 0x05) {
                        index += 2;
                        config.codec += "." + (description[index] >>> 3);
                      }
                    }
                  }
                }
              }
              if (config.codec == "mp4a.40") {
                // 応急処置
                config.codec = "mp4a.40.2";
              }
              console.log(config.codec);
              console.log(config, this);
              decoder.configure(config);
              this.decoders.audio = decoder;
              this.ctx = context;
            }
          }
        }
        async getFrame(frame) {
          let track = this.tracks.find((track)=>track.type=="video" && track.description!=undefined);
          if (frame <= this.decodedFrame.video) {
            await this.decoders.video.flush();
            this.frames.video.forEach((i)=>i.close());
            this.frames.video = [];
            this.__curVideoChunk = 0;
            this.decodedFrame.video = 0;
          }
          while (this.frames.video.reduce((total, i)=>total+(i.duration / (1000 ** 2)) * main.fps.video, this.decodedFrame.video) / this.options[0].timeScale <= frame || (track.chunks.length > this.__curVideoChunk+1 && track.chunks.at(this.__curVideoChunk+1).type != "key")) {
            let chunk = track.chunks.at(this.__curVideoChunk);
            this.__curVideoChunk += 1;
            if (chunk) {
              this.decoders.video.decode(chunk);
            } else {
              break;
            }
            if (track.chunks.length <= this.__curVideoChunk || track.chunks.at(this.__curVideoChunk).type == "key") {
              await this.decoders.video.flush();
            }
          }
          while (this.frames.video.length > 0 && ((this.frames.video[0].duration / (1000 ** 2)) * main.fps.video + this.decodedFrame.video) / this.options[0].timeScale < frame) {
            for (let i of this.frames.video.splice(0, 1)) {
              this.decodedFrame.video += (i.duration / (1000 ** 2)) * main.fps.video;
              i.close();
            }
            if (this.frames.video.length == 0) {
              break;
            }
          }
          return this.frames.video.at(0);
        }
        async getAudioNode() {
          this.audioBuffers = [];
          let track = this.tracks.find((track)=>track.type=="sound" && track.description!=undefined);
          for (let chunk of track.chunks) {
            this.decoders.audio.decode(chunk);
          }
          let promise = new Promise((resolve, reject)=>{
            this.decoders.audio.addEventListener("dequeue", ()=>{
              if (this.decoders.audio.decodeQueueSize == 0) {
                resolve();
              }
            })
          });
          await this.decoders.audio.flush();
          await promise;
          for (let audioData of this.audioDatas) {
            let audioBuffer = new AudioBuffer({
              length: audioData.duration * audioData.sampleRate / (1000 * 1000),
              numberOfChannels: audioData.format.endsWith("-planar")?audioData.numberOfChannels:1,
              sampleRate: audioData.sampleRate,
            });
            for (let ch=0; ch < audioData.numberOfChannels && audioData.format.endsWith("-planar") || ch == 0; ch++) {
              let buffer = new Float32Array(Math.round(audioData.allocationSize({planeIndex: ch}) / Math.round(parseInt(audioData.format.split("-")[0].slice(1)) / 8)));
              audioData.copyTo(buffer, {planeIndex: ch});
              audioBuffer.copyToChannel(buffer, ch, 0);
            }
            this.audioBuffers.push(audioBuffer);
          }
          let audioBuffersNode = new MultipleAudioBuffersSourceNode(
            this.ctx,
            this.audioBuffers,
            {
              channelCountMode: "max"
            }
          );
          return audioBuffersNode;
        }
        static async getSourceFromFileHandle(fileHandle) {
          if (!FileSystemFileHandle.prototype.isPrototypeOf(fileHandle)) {
            throw "given fileHandle is not a FileSystemFileHandle instance";
            return;
          }
          console.log(fileHandle.name);
          let file = await fileHandle.getFile();
          let path = (await main.dir.resolve(fileHandle)).join("/");
          const format = file.name.match(/(?:(?<=\.)[a-zA-Z0-9]*)?$/)[0].toLowerCase();
          let arrayBuffer = await file.arrayBuffer();
          return new this(file, path, arrayBuffer, format);
        }
      }

      class AudioSource extends SourceBase {
        static check(file) {
          return file.name.startsWith("audio/");
        }
        constructor(file, path, audioBuffer, format="wav") {
          super(file, path, format, SOURCE_TYPES.AUDIO);
          this.audioBuffer = audioBuffer;
          this.options[0].span = this.options[0].frames = [0, Math.ceil(this.audioBuffer.duration * main.fps.audio * 1000)];
          this.__preview = document.createElement("audio");
          if (!main.demo) {
            this.__preview.src = URL.createObjectURL(file);
          } else {
            this.__preview.src = new URL(path, main.dir);
          }
          this.options.forEach((option)=>{
            let addition = {
              volume: 1
            };
            for (let key of Object.keys(addition)) {
              option.addKey(key, addition[key]);
            }
            option.addEventListener("change", (e)=>{
              if (e.key == "timeScale") {
                this.__preview.playbackRate = isFinite(e.value)?e.value:1.0;
              } else if (e.key == "volume") {
                this.__preview.volume = e.value;
              }
            });
          });
        }
        hasAudio() {
          return true;
        }
        async decodeReady(ctx) {
          this.ctx = ctx;
        }
        async getAudioNode() {
          return new AudioBufferSourceNode(
            this.ctx,
            {
              buffer: this.audioBuffer
            }
          );
        }
        static async getSourceFromFileHandle(fileHandle) {
          if (!FileSystemFileHandle.prototype.isPrototypeOf(fileHandle)) {
            throw "given fileHandle is not a FileSystemFileHandle instance";
            return;
          }
          console.log(fileHandle.name);
          let file = await fileHandle.getFile();
          let path = (await main.dir.resolve(fileHandle)).join("/");
          const format = file.name.match(/(?:(?<=\.)[a-zA-Z0-9]*)?$/)[0].toLowerCase();
          let arrayBuffer = await file.arrayBuffer();
          let ctx = new AudioContext();
          let audioBuffer = await ctx.decodeAudioData(arrayBuffer);
          return new this(file, path, audioBuffer, format);
        }
      }

      class ImageSource extends SourceBase {
        static check(file) {
          return file.type.startsWith("image/");
        }
        constructor(file, path, format) {
          super(file, path, format, SOURCE_TYPES.IMAGE);
          this.options[0].span = [0, Math.ceil(1000 * main.fps.video)];
          if (format == "svg") {
            this.__svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            file.text().then((text)=>{
              let m = text.match(/<svg *(?<options>(?:(?:[a-zA-Z0-9:]+)(?:=(?:(?:'(?:[^']|\\')*')|(?:"(?:[^"]|\\")*")))? *)*) *>(?<innerHTML>(?:.|\s)*)<\/svg>/);
              let options = m.groups.options.matchAll(/(?<key>[a-zA-Z0-9:]+)(?:=(?<quote>['"])(?<value>(?:(?!\k<quote>).|\\\k<quote>)*)\k<quote>)?/g);
              for (let option of options) {
                if (option.groups.key == "width" && option.groups.value.endsWith("px")) {
                  this.width = parseFloat(option.groups.value);
                } else if (option.groups.key == "height" && option.groups.value.endsWith("px")) {
                  this.height = parseFloat(option.groups.value);
                } else if (option.groups.key == "viewBox") {
                  let box = option.groups.value.match(/(?<top>-?[0-9.]+) (?<left>-?[0-9.]+) (?<width>-?[0-9.]+) (?<height>-?[0-9.]+)/);
                  if (box) {
                    if (this.width == undefined) {
                      this.width = parseFloat(box.groups.width);
                    }
                    if (this.height == undefined) {
                      this.height = parseFloat(box.groups.height);
                    }
                  }
                }
                this.__svg.setAttribute(option.groups.key, option.groups.value||"");
              }
              this.__svg.innerHTML = m.groups.innerHTML;
              this.__preview = this.__svg.cloneNode(true);
              this.aspect.begin = this.aspect.end = this.width / this.height;
              if (this.options[0].width == undefined || this.options[0].height == undefined) {
                this.options[0].width.begin = this.options[0].width.end = this.width;
                this.options[0].height.begin = this.options[0].height.end = this.height;
              }
              this.options[0].addEventListener("change", (e)=>{
                if (e.key == "width" || e.key == "height") {
                  this.__preview.setAttribute(e.key, e.value.curValue + "px");
                }
              });
            });
          } else {
            this.__preview = document.createElement("img");
            if (!main.demo) {
              this.__preview.src = URL.createObjectURL(file);
            } else {
              this.__preview.src = new URL(path, main.dir);
            }
            this.__preview.decode().then(()=>{
              this.width = this.__preview.naturalWidth;
              this.height = this.__preview.naturalHeight;
              this.aspect = {begin:this.width / this.height, end:this.width / this.height};
              if (this.options[0].width == undefined || this.options[0].height == undefined) {
                this.options[0].width.begin = this.options[0].width.end = this.width;
                this.options[0].height.begin = this.options[0].height.end = this.height;
              }
            });
          }
        }
        async decodeReady() {
          this.lastFrame = undefined;
          if (await ImageDecoder.isTypeSupported(this.file.type)) {
            let arrayBuffer = await this.file.arrayBuffer();
            this.decoder = new ImageDecoder({type:this.file.type, data:arrayBuffer, premultiplyAlpha:"none", colorSpaceConversion:"none"});
          } else if (this.format == "svg") {
            this.decoder = ()=>{};
            this.decoder.decode = async (options)=>{
              let frame = options.index || 0;
              let width = this.options[0].width.curValue;
              let height = this.options[0].height.curValue;
              let videoFrame = await convertSVGToVideoFrame(this.__svg, {ms: 1000 * frame / main.fps.video, width: width, height: height});
              return {
                image: videoFrame,
                complete: true
              };
            };
          }
        }
        async getFrame(frame) {
          let result;
          try {
            return (await this.decoder.decode({index:frame})).image;
          } catch(e) {
            console.error(e);
            return undefined;
          }
        }
      }

      class TextSource extends SourceBase {
        static check(file) {
          return false;
        }
        constructor(text) {
          super({name:"テキスト"}, undefined, "", SOURCE_TYPES.TEXT);
          this.options[0].text = text;
          this.__preview = document.createElement("div");
          this.__preview.setAttribute("class", "text");
          this.__preview.append(
            document.createElement("p"),
            document.createElement("p")
          );
          this.options[0].span = [0, Math.ceil(1000 * main.fps.video)];
          this.options[0].frames = [...this.options[0].span];
          this.options.forEach((option)=>{
            let addition = {
              text: text,
              fontFamily: "auto",
              fontSize: new OptionValue(16),
              fontStyle: "normal",
              fontWeight: 400,
              lineHeight: new OptionValue(24),
              colorR: new OptionValue(0xff),
              colorG: new OptionValue(0xff),
              colorB: new OptionValue(0xff)
           };
            for (let key of Object.keys(addition)) {
              option.addKey(key, addition[key]);
            }
          });
          this.calcAll();
          this.__preview.style.fransformOrigin = "top left";
          this.options[0].addEventListener("change-width", (e)=>{
            this.__preview.style.width = "fit-content";
            this.__preview.style.transform = "scale(" + e.value.curValue / this.width + ", " + this.options[0].height.curValue / this.height + ")";
          });
          this.options[0].addEventListener("change-height", (e)=>{
            this.__preview.style.height = "fit-content";
            this.__preview.style.transform = "scale(" + this.options[0].width.curValue / this.width + ", " + e.value.curValue / this.height + ")";
          });
          this.options[0].addEventListener("posOrigin", (e)=>{
            if (e.value == "top-left") {
              this.__preview.style.transformOrigin= "top left";
            } else if (e.value == "center") {
              this.__preview.style.tranformOrigin = "center center";
            }
          });
          this.options.forEach((option)=>{option.redraw()});
        }
        calcAll() {
          let dummy = document.createElement("span");
          dummy.innerText = this.options[0].text;
          dummy.style.whiteSpace="pre";
          dummy.style.opacity = 0;
          dummy.style.fontFamily = this.options[0].fontFamily;
          dummy.style.fontSize = this.options[0].fontSize.begin + "px";
          dummy.style.fontStyle = this.options[0].fontStyle;
          dummy.style.fontWeight = this.options[0].fontWeight;
          dummy.style.lineHeight = (this.options[0].lineHeight.begin || this.options[0].fontSize.begin*1.5) + "px";
          dummy.style.margin = 0;
          //dummy.style.width = dummy.style.height = "fit-content";
          document.body.appendChild(dummy);
          let rect = dummy.getBoundingClientRect();
          dummy.remove();
          this.width = rect.width;
          this.height = rect.height;
          this.aspect.begin = this.width / this.height;
          this.options[0].width.begin = this.width;
          this.options[0].height.begin = this.height;

          dummy.style.fontSize = this.options[0].fontSize.end + "px";
          dummy.style.lineHeight = (this.options[0].lineHeight.end || this.options[0].fontSize.end*1.5) + "px";
          document.body.appendChild(dummy);
          rect = dummy.getBoundingClientRect();
          dummy.remove();
          this.aspect.end = rect.width / rect.height;
          this.options[0].width.end = rect.width;
          this.options[0].height.end = rect.height;
        }
        setupDetail() {
          super.setupDetail();
          let px = document.createElement("span");
          px.setAttribute("class", "px");
          px.innerText = "px";
          let percent = document.createElement("span");
          percent.setAttribute("class", "percent");
          percent.innerText = "%";

          let div = document.createElement("div");
          let label = document.createElement("label");
          label.innerText = "テキスト";
          label.setAttribute("for", "text");
          let text = document.createElement("textarea");
          text.setAttribute("name", "text");
          div.append(label, text);
          this.__detail.appendChild(div);

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "フォントサイズ";
          label.setAttribute("for", "font-size");
          let size = document.createElement("transitional-input");
          size.setAttribute("name", "font-size");
          size.setAttribute("type", "number");
          div.append(label, size, px.cloneNode(1));
          this.__detail.appendChild(div);

          /* div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "フォントサイズ";
          label.setAttribute("for", "font-size");
          let size = document.createElement("input");
          alpha.setAttribute("name", "font-size");
          alpha.setAttribute("type", "number");
          div.append(label, size, px.cloneNode(1));
          this.__detail.appendChild(div); */

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "文字の太さ";
          label.setAttribute("for", "font-weight");
          let weight = document.createElement("input");
          weight.setAttribute("name", "font-weight");
          weight.setAttribute("type", "number");
          div.append(label, weight);
          this.__detail.appendChild(div);

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "行の高さ";
          label.setAttribute("for", "line-height");
          let height = document.createElement("transitional-input");
          height.setAttribute("name", "line-height");
          height.setAttribute("type", "number");
          div.append(label, height, px.cloneNode(1));
          this.__detail.appendChild(div);

          div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "文字の色";
          label.setAttribute("for", "color");
          let color = document.createElement("transitional-input");
          color.setAttribute("name", "color");
          color.setAttribute("type", "color");
          div.append(label, color);
          this.__detail.appendChild(div);

          /* div = document.createElement("div");
          label = document.createElement("label");
          label.innerText = "フォントサイズ";
          label.setAttribute("for", "font-size");
          let size = document.createElement("input");
          alpha.setAttribute("name", "font-size");
          alpha.setAttribute("type", "number");
          div.append(label, size, px.cloneNode(1));
          this.__detail.appendChild(div); */

          text.addEventListener("input", (e)=>{this.options[0].text = e.target.value;});
          //fontFamily.addEventListener("change", (e)=>{this.options[0].fontFamily = e.target.value;});
          size.begin.addEventListener("change", (e)=>{this.options[0].fontSize.begin = e.target.value;});
          size.end.addEventListener("change", (e)=>{this.options[0].fontSize.end = e.target.value;});
          //fontStyle.addEventListener("change", (e)=>{this.options[0].fontStyle = e.target.value;});
          weight.addEventListener("change", (e)=>{this.options[0].fontWeight = e.target.value;});
          height.begin.addEventListener("change", (e)=>{this.options[0].lineHeight.begin = e.target.value;});
          height.end.addEventListener("change", (e)=>{this.options[0].lineHeight.end = e.target.value;});
          color.begin.addEventListener("change", (e)=>{[this.options[0].colorR.begin, this.options[0].colorG.begin, this.options[0].colorB.begin] = e.target.value.match(/[0-9a-fA-F]{2}/g).map((m)=>parseInt(m, 16));});
          color.end.addEventListener("change", (e)=>{[this.options[0].colorR.end, this.options[0].colorG.end, this.options[0].colorB.end] = e.target.value.match(/[0-9a-fA-F]{2}/g).map((m)=>parseInt(m, 16));});

          this.options[0].addEventListener("change", (e)=>{
            /* text: text,
              fontFamily: "auto",
              fontSize: 16,
              fontStyle: "normal",
              fontWeight: 400,
              lineHeight: 24,
              color: "#ffffff" */
            if (e.key == "text") {
              text.value = e.value;
              this.__preview.children[0].innerText = this.__preview.children[1].innerText = e.value;
              this.calcAll();
            } else if (e.key == "fontFamily") {
              fontFamily.value = this.__preview.style.fontFamily = e.value;
              this.calcAll();
            } else if (e.key == "fontSize") {
              size.begin.value = e.value.begin;
              size.end.value = e.value.end;
              this.__preview.style.fontSize = e.value.curValue + "px";
              this.calcAll();
            } else if (e.key == "fontStyle") {
              fontStyle.value = this.__preview.style.fontStyle = e.value;
              this.calcAll();
            } else if (e.key == "fontWeight") {
              weight.value = this.__preview.style.fontWeight = e.value;
              this.calcAll();
            } else if (e.key == "lineHeight") {
              height.begin.value = e.value.begin;
              height.end.value = e.value.end;
              this.__preview.style.lineHeight = e.value.curValue + "px";
              this.calcAll();
            } else if (["colorR", "colorG", "colorB"].includes(e.key)) {
              color.begin.value = "#"+this.options[0].colorR.begin.toString(16).padStart(2, "0")+this.options[0].colorG.begin.toString(16).padStart(2, "0")+this.options[0].colorB.begin.toString(16).padStart(2, "0");
              color.end.value = "#"+this.options[0].colorR.end.toString(16).padStart(2, "0")+this.options[0].colorG.end.toString(16).padStart(2, "0")+this.options[0].colorB.end.toString(16).padStart(2, "0");
              this.__preview.style.color = "rgb("+this.options[0].colorR.curValue+", "+this.options[0].colorG.curValue+", "+this.options[0].colorB.curValue+")";
            }
          });
          this.options[0].redraw();
        }
        async decodeReady() {
          this.__svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.textContent = this.options[0].text;
          text.innerHTML = text.innerHTML.replaceAll("\n", "<tspan x=\"0\" dy=\"1em\"></tspan>");
          text.setAttribute("dominant-baseline", "text-before-edge");
          this.__svg.appendChild(text);
          this.__svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        }
        async getFrame(frame) {
          if (this.options[0].width.curValue < 1 || this.options[0].height.curValue < 1) {
            return;
          }
          this.__svg.setAttribute("viewBox", "0 0 "+this.options[0].width.curValue+" "+this.options[0].height.curValue);
          this.__svg.setAttribute("width", this.options[0].width.curValue+"px");
          this.__svg.setAttribute("height", this.options[0].height.curValue+"px");
          this.__svg.children[0].setAttribute("fill", "#"+Math.round(this.options[0].colorR.curValue).toString(16).padStart(2, "0")+Math.round(this.options[0].colorG.curValue).toString(16).padStart(2, "0")+Math.round(this.options[0].colorB.curValue).toString(16).padStart(2, "0"));
          this.__svg.children[0].style.fontSize = this.options[0].fontSize.curValue + "px";
          let videoFrame = await convertSVGToVideoFrame(this.__svg, {width: this.options[0].width.curValue, height: this.options[0].height.curValue});
          return videoFrame;
        }
      }

      class EffectBase extends Object {
        constructor() {
          super();
        }
        async playPreview() {
        }
        async pausePreview() {
        }
        async stopPreview() {
        }
        preparePreview(el) {
        }
        async handleFrame(data) {
        }
      }

      class MaskEffect extends EffectBase {
        constructor() {
          super();
          this.animation = undefined;
        }
        preparePreview(el, options={}) {
          if (this.animation) {
            this.animation.currentTime = 0;
            this.animation.cancel();
          }
          this.animation = el.animate(
            [
              {},
              {width: "0px"}
            ],
            {
              duration: options.frames?(options.frames[1] - options.frames[0])/main.fps.video:0,
              iterations: 1
            }
          );
          this.animation.pause();
        }
        async playPreview() {
          this.animation.play();
        }
        async pausePreview() {
          this.animation.pause();
        }
        async stopPreview() {
          this.animation.cancel();
          this.animation.currentTime = 0;
        }
        
      }

      class EditorMain extends EventTarget {
        constructor() {
          super();
          this.demo = location.search.match(/(?<=[?&])demo/) != null; // 学園祭デモ用
          this.ms = 0;
          this.isStereo = true;
          this.tree = new SourceClassTree();
          this.seqUnitIndex = 0;
          this.playing = false;
          this.span = [0, 0];
          this.layers = [[],];
          this.materials = [];
          this.fps = {
            video: 30,
            audio: 30
          };
          this.sampleRate = 48000;
          this.size = {
            width: 1920,
            height: 1080
          };
          this.timeScale = 1;
          this.timelineWidth = document.querySelector(".layers").clientWidth;
          this.__timelineUnitWidth = -1;
          this.__points = [];
          this.ctrlKey = false;
          this.scrolling = false;
          this.__scrollTimeout = -1;
          this.pinchDelta = {x:0, y:0, z:0};

          this.makeCompatible();
          let unsupported = [];
          let compatible = [];
          for (let target of ["VideoDecoder", "AudioDecoder", "VideoEncoder", "AudioEncoder", "ImageDecoder", "AudioContext", "OfflineAudioContext", ...(this.demo?[]:["showOpenFilePicker", "showDirectoryPicker"])]) {
            if (!window.hasOwnProperty(target)) {
              unsupported.push(target);
              window[target] = undefined;
            } else if (window[target].compatible == true) {
              compatible.push(target);
            }
          }
          if (unsupported.length > 0 || compatible.length > 0) {
            let element = document.createElement("div");
            if (unsupported.length > 0) {
              let description = document.createElement("p");
              description.innerText = "以下の機能がご使用のブラウザに実装されていないため、正常に動作できない可能性があります:";
              element.appendChild(description);
              element.appendChild(document.createElement("ul"));
              for (let target of unsupported) {
                element.lastChild.appendChild(document.createElement("li"));
                element.lastChild.lastChild.innerText = target;
              }
            }
            if (compatible.length > 0) {
              let description = document.createElement("p");
              description.innerText = "以下の機能は代替したため、動作が不完全となる可能性があります:";
              element.appendChild(description);
              element.appendChild(document.createElement("ul"));
              for (let target of compatible) {
                element.lastChild.appendChild(document.createElement("li"));
                element.lastChild.lastChild.innerText = target;
              }
            }
            Prompts.showError(element);
          }
          if (this.demo) {
            document.querySelector("pop-up#demo-description").activate();
          }
          document.getElementsByName("newpro")[0].addEventListener("click", async (e)=>{
            await this.createProject();
          });
          document.getElementsByName("import")[0].addEventListener("click", async (e)=>{
            if (this.demo) {
              await Prompts.showError("この機能はデモ版では利用できません");
              return;
            }
            if (this.dir == undefined) {
              await Prompts.showError("先に新規プロジェクトを作成またはプロジェクトを読み込んでね。");
              return;
            }
            let fileHandles = [];
            if (showOpenFilePicker) {
              fileHandles = await showOpenFilePicker({multiple:true});
            } else {
            }
            let result = [];
            for (let fileHandle of fileHandles) {
              let file = await fileHandle.getFile();
              let cls = await this.tree.getSourceClass(file) || SourceBase;
              let material = await this.getMaterial(fileHandle);
              result.push(await cls.getSourceFromFileHandle(material.fileHandle));
            }
            console.log(result);
            for (let src of result) {
              document.querySelector("body > div > div.area.below > div > ul.layers > li-layer").appendChild(src.sourceElement);
              this.pushSrcAt(0, -1, src);
            }
          });
          setTimeout(async()=>{
            await this.handleTimelineWidth();
            await this.handleTimelineScroll();
          }, 0);
          window.addEventListener("beforeunload", (e)=>{e.preventDefault();e.returnValue="";});
          document.getElementsByName("savepro")[0].addEventListener("click", async (e)=>{await this.saveProject();});
          document.getElementsByName("openpro")[0].addEventListener("click", async (e)=>{await this.loadProject();});
          document.getElementsByName("create-text")[0].addEventListener("click", async (e)=>{this.createText("テキスト");});
          document.getElementsByName("play-preview")[0].addEventListener("click", async (e)=>{await this.playPreview();});
          document.getElementsByName("stop-preview")[0].addEventListener("click", async (e)=>{await this.stopPreview();});
          new ResizeObserver(()=>{document.getElementById("dynamic").sheet.rules[1].style.setProperty("--unit-px", document.querySelector(".preview").clientWidth / this.size.width);}).observe(document.querySelector(".preview"));
          window.addEventListener("keydown", (e)=>{return this.handleKeyState(e);});
          window.addEventListener("keyup", (e)=>{return this.handleKeyState(e);});
          document.querySelector(".timeline").addEventListener("scroll", async (e)=>{await this.handleTimelineScroll(e);});
          document.querySelector(".timeline").addEventListener("scroll", (e)=>{console.log("scrollstart");this.pinchDelta={x:0, y:0, z:0};if (this.__scrollTimeout >= 0) {clearTimeout(this.__scrollTimeout);this.__ScrollTimeout = -1;}this.scrolling = true;this.__scrollTimeout = setTimeout(()=>{this.scrolling = false;this.__scrollTimeout = -1;}, 200);});
          document.querySelector(".timeline").addEventListener("scrollend", (e)=>{console.log("scrollend");this.scrolling = false;});
          //document.querySelector(".layers > input[name=\"time\"]").addEventListener("change", async (e)=>{if (Math.random() > 0.5) {await this.handleSeek(e);}});
          document.querySelector(".layers > input[name=\"time\"]").addEventListener("input", async (e)=>{await this.handleSeek(e);});
          document.querySelector("input[type=\"range\"][name=\"time\"]").addEventListener("mousedown", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector("input[type=\"range\"][name=\"time\"]").addEventListener("touchstart", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector("input[type=\"range\"][name=\"time\"]").addEventListener("mouseover", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers > div.wrapper").addEventListener("mousedown", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers > div.wrapper").addEventListener("touchstart", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers > div.wrapper").addEventListener("mouseover", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers").addEventListener("pointerdown", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers").addEventListener("pointermove", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers").addEventListener("pointerup", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers").addEventListener("pointerout", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers").addEventListener("pointerover", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers").addEventListener("pointercancel", (e)=>{return this.handleSequencePointerEvent(e);});
          document.querySelector(".layers").addEventListener("wheel", (e)=>{return this.handleSequencePointerEvent(e);});
          /*document.querySelector("pop-up#encode form").addEventListener("submit", (e)=>{
            let options = {
              format: e.target.format.value,
              codecs:{
                audio: e.target.acodec.value,
                video: e.target.vcodec.value
              },
            };
            this.encode(options);
          });*/ // 一旦無効化
        }

        makeCompatible() {
          if (window.ImageDecoder == undefined) {
            try {
              class _ImageDecoder {
                static compatible = true;
                constructor(init) {
                  if (init.type == undefined || init.data == undefined && init.transfer == undefined) {
                    throw "Lack of some required options";
                  }
                  this._type = init.type;
                  this._data = init.data;
                  this._premultiplyAlpha = init.premultiplyAlpha || "default";
                  this._colorSpaceConversion = init.colorSpaceConversion || "default";
                  this._desiredWidth = init.desiredWidth;
                  this._desiredHeight = init.desiredHeight;
                  this._preferAnimation = init.preferAnimation;
                  this._transfer = init.transfer;

                  if (this._desiredWidth != undefined) {
                    if (this._desiredHeight != undefined) {
                      this._img = new Image(this._desiredWidth, this._desiredHeight);
                    } else {
                      this._img = new Image(this._desiredWidth);
                    }
                  } else {
                    this._img = new Image();
                  }
                  let blob = new Blob([this._data], {type:this._type})
                  let url = URL.createObjectURL(blob);
                  this._img.src = url;
                  
                  this._ready = new Promise((resolve, reject)=>{
                    this._img.decode().then(()=>{
                      this._canvas = document.createElement("canvas");
                      this._canvas.width = this._img.width;
                      this._canvas.height = this._img.height;
                      let ctx = this._canvas.getContext("2d", {alpha:true});
                      ctx.drawImage(this._img, 0, 0);
                      resolve();
                    }).catch(reject).finally(()=>{URL.revokeObjectURL(this._img.src);});
                  });

                  this._complete = false;
                  this._completed = new Promise((resolve, reject)=>{
                    this._completed_resolve = resolve;
                    this._completed_reject = reject;
                  });

                  if (true) {}
                }
                get type() {
                  return this._type;
                }
                static isTypeSupported(type) {
                  return true;
                }
                _complete(result) {
                  this._complete = result;
                  if (result) {
                    this._completed_resolve();
                  } else {
                    this._completed_reject();
                  }
                }
                get complete() {
                  return this._complete;
                }
                get completed() {
                  return this._completed;
                }
                async decode(options) {
                  await this._ready;
                  return {
                    image: new VideoFrame(this._canvas, {timestamp: 0}),
                    complete: true
                  };
                }
                close() {}
              };
              window.ImageDecoder = _ImageDecoder;
            } catch {}
          }
        }

        createText(text="Text here...") {
          let src = new TextSource(text);
          this.pushSrcAt(0, -1, src);
          document.querySelector("li-layer[index=\"0\"]").appendChild(src.sourceElement);
        }

        pushSrcAt(layer, index, src) {
          layer = Math.floor(layer);
          index = Math.min(Math.floor(index), this.layers[layer].length);
          this.layers[layer].splice(index, 0, src);
          let dummy = this.layers[layer].filter((target, i)=>target!=src||i==index);
          dummy.sort((a, b)=>a.options[0].frames[0]-b.options[0].frames[0]);
          let dummyIndex = dummy.indexOf(src);
          for (let i = Math.max(0, dummyIndex); i < dummy.length; i++) {
            if (i > 0) {
              let delay = dummy[i].options[0].frames[0] - dummy[i-1].options.at(-1).frames[1];
              console.log(delay)
              if (delay < 0) {
                for (let option of dummy[i].options) {
                  option.frames = option.frames.map((i)=>i-delay);
                }
              } else if (i > dummyIndex) {
                break;
              }
            }
          }
          if (this.layers.at(-1).length > 0) {
            this.layers.push([]);
            let el = document.createElement("li-layer");
            el.setAttribute("index", layer+1);
            document.querySelector(".layers").appendChild(el);
          }
        }

        removeSrcAt(layer, index) {
          layer = Math.floor(layer);
          index = Math.floor(index);
          let result = this.layers[layer].splice(index, 1)[0];
          for (let i=this.layers.length-1; i > 0; i--) {
            if (this.layers[i].length == 0 && this.layers[i-1].length == 0) {
              this.layers.splice(i, 1);
              document.querySelector("li-layer[index=\""+i+"\"").remove();
            } else {
              break;
            }
          }
        }

        async getMaterial(fileHandle) {
          let path = (await this.dir.resolve(fileHandle)).join("/");
          let material = this.materials.find((material)=>{
            return material.path == path;
          });
          if (material == undefined) {
            material = new Material(fileHandle, path);
            this.materials.push(material);
          }
          return material;
        }

        handleTimelineWidth() {
          let timelineWidth = Math.max(...this.layers.map((layer)=>Math.max(...layer.map((src)=>Math.max(...src.options.map((option)=>option.frames[1]))))), 
            (document.querySelector(".timeline").clientWidth - document.querySelector(".layer-tips").clientWidth) * 1000 / this.timeScale
          );
          document.querySelector(".layers").style.width = "calc(var(--unit-length) * " + timelineWidth + " / 1000)";
          document.querySelector(".layers").style.minWidth = "calc(var(--unit-length) * " + timelineWidth + " / 1000)";
          document.querySelector("input[name=\"time\"]").setAttribute("max", timelineWidth);
          this.timelineWidth = timelineWidth;
          return timelineWidth;
        }

        async handleSeek(e) {
          let wasPlaying = this.playing;
          let curFrame = parseInt(document.querySelector(".layers > input[name=\"time\"]").value);
          if (this.playing) {
            await this.stopPreview();
            await waitUntil(this, "play-stop");
          }
          let els = [];
          for (let layer of this.layers) {
            for (let src of layer) {
              if (src.options[0].frames[0] <= curFrame && src.options.at(-1).frames[1] >= curFrame) {
                els.push(src.previewElement);
                if (src.type == SOURCE_TYPES.VIDEO || src.type == SOURCE_TYPES.AUDIO) {
                  src.previewElement.currentTime = (src.options[0].span[0] + (curFrame - src.options[0].frames[0]) / src.options[0].timeScale) / (this.fps.video * 1000);
                }
                src.options.forEach((option)=>Object.keys(option.__option).forEach((key)=>{if(OptionValue.prototype.isPrototypeOf(option.__option[key])){option.__option[key].time = (curFrame * 1000 - src.options[0].frames[0])/(src.options[0].frames[1]-src.options[0].frames[0]);option[key]=option.__option[key];}}))
              }
            }
          }
          document.querySelector(".preview").replaceChildren(...els);
          if (wasPlaying) {
            await this.playPreview(curFrame);
          }
        }

        handleSequencePointerEvent(e) {
          if (e.type == "mousedown" || e.type == "touchstart") {
            let els;
            if (e.type == "mousedown") {
              els = document.elementsFromPoint(e.x, e.y);
            } else {
              if (e.touches.length > 1) {
                els = [];
              } else {
                els = document.elementsFromPoint(e.touches[0].clientX, e.touches[0].clientY);
              }
            }
            console.log(e);
            let src;
            if (els.some((el)=>{
              if (el.tagName == "SRC-OBJ") {
                el.click();
                src = el;
                return true;
              } else {
                return false;
              }
            })) {
              try {
                e.preventDefault();
              } catch {}
              let aborter = new AbortController();
              let pos = src.getBoundingClientRect();
              let ppos = src.offsetParent.getBoundingClientRect();
              console.log([pos, ppos]);
              let offset;
              if (e.type == "mousedown") {
                offset = {top: ppos.y + e.y - pos.y, left: ppos.x + e.x - pos.x};
              } else {
                offset = {top: ppos.y + e.touches[0].clientY - pos.y, left: ppos.x + e.touches[0].clientX - pos.x};
              }
              console.log(offset);
              src.style.top = src.offsetTop + "px";
              src.style.left = src.offsetLeft + "px";
              src.style.position = "absolute";
              src.style.zIndex = 15;
              let prevIndex = [...src.parentElement.children].indexOf(src);
              let prevLayer = new Number(src.parentElement.getAttribute("index"));
              let canMove = true;
              let left = src.offsetLeft;
              let timelineWidth = this.handleTimelineWidth();
              let callback = (ev)=>{
                let top;
                if (ev.type == "mousemove") {
                  top = (ev.y - offset.top);
                  left = (ev.x - offset.left);
                } else {
                  top = (ev.touches[0].clientY - offset.top);
                  left = (ev.touches[0].clientX - offset.left);
                }
                let layer = Math.round(prevLayer + src.offsetTop/src.parentElement.clientHeight);
                src.style.top = top + "px";
                src.style.left = left + "px";
                //console.log([left, pos.left, ppos.left]);
                document.querySelector(".layers").style.minWidth = "calc(var(--unit-length) * " + (Math.max(timelineWidth, (left + pos.width) * 1000, (pos.left - ppos.left + pos.width) * 1000) / this.timeScale) + " / 1000)";
                if (ev.buttons == 0) {
                  aborter.abort();
                }
                ;
              };
              window.addEventListener("mousemove", callback, {signal: aborter.signal});
              window.addEventListener("touchmove", callback, {signal: aborter.signal});
              let leave = ()=>{
                aborter.abort();
                let curLayer = Math.min(this.layers.length-1, Math.max(0, Math.round(prevLayer + src.offsetTop/src.parentElement.clientHeight)));
                let curIndex = this.layers[curLayer].filter((src, index)=>index!=prevIndex).map((src)=>src.options[0].frames[0]).findIndex((frame)=>frame > left * 1000 / this.timeScale);
                if (curIndex == -1) {
                  curIndex = this.layers[curLayer].length; // - (curLayer == prevLayer);
                } else {
                  curIndex = Math.max(0, curIndex - 1);
                }
                let leftDiff = Math.max(0, Math.round(left * 1000 / this.timeScale)) - this.layers[prevLayer][prevIndex].options[0].frames[0];
                console.log(leftDiff);
                if (left>=1.5 || left <= -1.5) {
                  for (let option of this.layers[prevLayer][prevIndex].options) {
                    option.frames = [option.frames[0] + leftDiff, option.frames[1] + leftDiff];
                  }
                }
                src.style.zIndex = "";
                src.style.top = "";
                src.style.left = "calc(var(--unit-length) * "+this.layers[prevLayer][prevIndex].options[0].frames[0]+" / 1000)";
                console.log(src);
                let source = this.layers[prevLayer][prevIndex];
                if (curLayer != prevLayer) {
                  src.remove();
                }
                this.pushSrcAt(curLayer, curIndex, source);
                this.removeSrcAt(prevLayer, prevIndex+(curLayer==prevLayer&&curIndex < prevIndex));
                let layer = document.querySelector("li-layer[index=\""+curLayer+"\"]");
                layer.replaceChildren(...this.layers[curLayer].map((src)=>src.sourceElement));
                this.handleTimelineWidth();
              };
              window.addEventListener("mouseup", leave, {signal: aborter.signal});
              window.addEventListener("touchend", leave, {signal: aborter.signal});
            } else {
              ;
            }
          } else if (e.type == "pointerdown") {
            if (!this.__points.some((ev)=>ev.pointerId == e.pointerId)) {
              this.__points.push(e);
              if (this.__points.length == 2) {
                e.preventDefault();
                this.__points.prevDiff = (Math.abs(this.__points[1].clientX - this.__points[0].clientX)**2 + Math.abs(this.__points[1].clientY - this.__points[0].clientY)**2) ** 0.5;
              }
            }
          } else if (e.type == "pointermove") {
            if (this.__points.length == 2) {
              //console.log(e);
              e.preventDefault();
              let index = this.__points.findIndex((ev)=>ev.pointerId == e.pointerId);
              this.__points[index] = e;
              let curDiff = (Math.abs(this.__points[1].clientX - this.__points[0].clientX)**2 + Math.abs(this.__points[1].clientY - this.__points[0].clientY)**2) ** 0.5;
              this.changeTimeScale(curDiff - this.__points.prevDiff);
              this.__points.prevDiff = curDiff;
            }
          } else if (["pointerup", "pointerleave", "pointerout", "pointercancel"].includes(e.type)) {
            if (this.__points.some((ev)=>ev.pointerId == e.pointerId)) {
              this.__points = this.__points.filter((ev)=>ev.pointerId!=e.pointerId);
            }
          } else if (e.type == "wheel") {
            if (this.__scrollTimeout >= 0) {
              clearTimeout(this.__scrollTimeout);
              this.__scrollTimeout = setTimeout(()=>{this.scrolling = false;this.__scrollTimeout = -1;this.pinchDelta={x:0, y:0, z:0};}, 200);
            } else if (e.ctrlKey && !this.scrolling) {
              e.preventDefault();
              if (this.__pinchTimeout) {
                clearTimeout(this.__pinchTimeout);
              }
              this.pinchDelta.x += e.deltaX;
              this.pinchDelta.y += e.deltaY;
              this.pinchDelta.z += e.deltaZ;
              this.changeTimeScale(1 - ((this.pinchDelta.x + this.pinchDelta.y > 0) * 2)*(this.pinchDelta.x ** 2 + this.pinchDelta.y ** 2) ** 0.5);
              this.pinchDelta = {x:0, y:0, z:0};
              this.__pinchTimeout = setTimeout(()=>{
                delete this.__pinchTimeout;
                this.pinchDelta = {x:0, y:0, z:0};
              }, 150);
            }
          }
        }

        changeTimeScale(value, center=0) {
          this.timeScale = Math.min(this.timeScale * (10 ** (value / 500)), 1000);
          document.getElementById("dynamic").sheet.rules[0].style.cssText = "--unit-length: " + this.timeScale + "px;";
          this.handleTimelineWidth();
          this.handleTimelineScroll();
        }

        async handleKeyState(e) {
          this.ctrlKey = e.ctrlKey;
        }

        async handleTimelineScroll(e) {
          let seq = document.querySelector(".sequence-scale");
          let unitWidth = this.timeScale * this.fps.video * (2**(Math.ceil(Math.log2((this.timeScale)))-1)) * (2**Math.ceil(Math.log2((document.querySelector(".timeline").clientWidth - document.querySelector(".layer-tips").clientWidth) / (4*this.fps.video))-1));
          let redraw = (unitWidth != this.__timelineUnitWidth);
          if (redraw) {
            this.__timelineUnitWidth = unitWidth;
          }

          document.getElementById("dynamic").sheet.rules[2].style.cssText = "--scale-length: " + unitWidth + "px";
          let scrollLeft = document.querySelector(".timeline").scrollLeft;
          let many = 4 + Math.ceil((document.querySelector(".timeline").clientWidth - document.querySelector(".layer-tips").clientWidth) / unitWidth);
          let secPerScale = unitWidth / (this.timeScale * this.fps.video);

          function unitText(index) {
            let time = new TimeDelta(secPerScale*index);
            if (time.hour == 0) {
              if (time.minute == 0) {
                return time.second.toString()+"."+time.millisecond.toString().padStart(3, "0");
              } else {
                return time.minute.toString()+":"+time.second.toString().padStart(2, "0")+"."+time.millisecond.toString().padStart(3, "0");
              }
            } else {
              return time.hour.toString()+":"+time.minute.toString().padStart(2, "0")+":"+time.second.toString().padStart(2, "0")+"."+time.millisecond.toString().padStart(3, "0");
            }
          }

          let lefts = [];
          let rights = [];
          if (unitWidth*(this.seqUnitIndex+0) - scrollLeft > 0 || (seq.children.length != many && unitWidth*this.seqUnitIndex - scrollLeft >= 0)) {
            for (let i = 0; i < many - seq.children.length; i++) {
              let el = document.createElement("span");
              el.innerText = unitText(this.seqUnitIndex+many-i-1);
              lefts.push(el);
            }
            for (let i = 1; i < seq.children.length - many + 1 - lefts.length; i++) {
              rights.push(seq.children.length-i);
            }
            for (let i = many - seq.children.length + 1; i < many - seq.children.length + Math.ceil(this.seqUnitIndex + 2 - scrollLeft/unitWidth) && this.seqUnitIndex >= i; i++) {
              if (many+lefts.length-i < 0) {break;}
              if (unitWidth*(this.seqUnitIndex+1+lefts.length) >= this.timelineWidth) {break;}
              let el = document.createElement("span");
              el.innerText=unitText(this.seqUnitIndex-i);
              lefts.push(el);
              rights.push(seq.children.length-i);
            }
            for (let i of lefts) {
              seq.insertAdjacentElement("afterbegin", i);
            }
            for (let i of rights.slice(0, Math.max(0, rights.length + seq.children.length - many))) {
              try {
                seq.children[lefts.length+i].remove();
              } catch(e) {}
            }
            this.seqUnitIndex -= rights.length;
            seq.style.paddingLeft = "calc(var(--scale-length) * " + this.seqUnitIndex + ")";
          }
          lefts = [];
          rights = [];
          if (unitWidth*(this.seqUnitIndex) - scrollLeft < 0 || (seq.children.length != many && unitWidth*this.seqUnitIndex - scrollLeft <= 0)) {
            for (let i = many-seq.children.length; i > 0; i--) {
              let el = document.createElement("span");
              el.innerText = unitText(this.seqUnitIndex + many + i);
              rights.push(el);
            }
            for (let i = 0; i < seq.children.length - many - rights.length; i++) {
              lefts.push(i);
            }
            for (let i = many - seq.children.length; i < many - seq.children.length + Math.ceil(scrollLeft/unitWidth - this.seqUnitIndex - 2) && this.seqUnitIndex >= i; i++) {
              if (i >= many+rights.length) {break;}
              if (unitWidth*(this.seqUnitIndex+1-rights.length) <= 0) {break;}
              lefts.push(i);
              let el = document.createElement("span");
              el.innerText = unitText(this.seqUnitIndex + many + i);
              rights.push(el);
            }
            if (lefts.length >= seq.children.length) {
              seq.replaceChildren(...rights.slice(-1*many));
            } else {
              lefts = lefts.reverse();
              for (let i of rights) {
                seq.insertAdjacentElement("beforeend", i);
              }
              for (let i of lefts.slice(0, Math.max(0, lefts.length + seq.children.length - many))) {
                try {
                  seq.children[i].remove();
                } catch {}
              }
            }
            this.seqUnitIndex += lefts.length;
            seq.style.paddingLeft = "calc(var(--scale-length) * " + this.seqUnitIndex + ")";
          }
        }

        async playPreview(start, end) {
          if (this.playing) {
            this.stopPreview();
            return;
          }
          this.playing = true;
          if (start) {
            document.querySelector(".preview").replaceChildren();
          }
          let timings = [];
          let prevFrame = 0;
          let playingFrame = start!=undefined?start-1:parseInt(document.querySelector(".layers > input[name=\"time\"]").value);
          let layerIndex = 0;
          for (let layer of this.layers) {
            let timing = [];
            for (let src of layer) {
              if (src.previewElement) {
                console.log(src.previewElement);
                src.previewElement.style.zIndex = layerIndex+1;
              }
              let callbacks = {start:async (src)=>{}, end:async (src)=>{}, pause:async (src)=>{}};
              for (let effect of src.options[0].effects) {
                effect.preparePreview(src.previewElement, src.options[0]);
              }
              if (src.type == SOURCE_TYPES.VIDEO || src.type == SOURCE_TYPES.AUDIO) {
                //src.previewElement.playbackRate /= 4;
                callbacks.start = async (src, frame)=>{
                  src.previewElement.currentTime = ((src.options[0].span[0] + frame / src.options[0].timeScale) / this.fps.video) / 1000;
                  await Promise.all(src.options[0].effects.map((effect)=>effect.playPreview()));
                  document.querySelector(".preview").appendChild(src.previewElement);
                  src.previewElement.play();
                  //window.addEventListener("pointermove", (e)=>{try{src.previewElement.removeAttribute("muted");}catch{}}, {passive:true, once:true});
                };
                callbacks.end = async (src)=>{
                  src.previewElement.pause();
                  src.previewElement.remove();
                  await Promise.all(src.options[0].effects.map((effect)=>effect.stopPreview()));
                };
                callbacks.pause = async (src)=>{
                  src.previewElement.pause();
                  await Promise.all(src.options[0].effects.map((effect)=>effect.pausePreview()));
                }
              } else {
                callbacks.start = async (src)=>{
                  await Promise.all(src.options[0].effects.map((effect)=>effect.playPreview()));
                  document.querySelector(".preview").appendChild(src.previewElement);
                };
                callbacks.end = async (src)=>{
                  src.previewElement.remove();
                  await Promise.all(src.options[0].effects.map((effect)=>effect.stopPreview()));
                };
                callbacks.pause = async (src)=>{
                  await Promise.all(src.options[0].effects.map((effect)=>effect.pausePreview()));
                }
              }
              timing.push([...src.options[0].frames, callbacks, src]);
            }
            timings.push(timing);
            layerIndex += 1;
          }
          console.log(timings);
          let lastFrame = end!=undefined?end:Math.max(0, ...timings.map((timing)=>Math.max(0, ...timing.map((i)=>i[1]))));
          if (lastFrame < playingFrame) {
            playingFrame = 0;
          }
          console.log(lastFrame)
          let playingId = [];
          let startTime = Date.now() - (playingFrame / this.fps.video);
          let interval = setInterval(async ()=>{
            let curTime = Date.now();
            let curFrame = Math.round((curTime - startTime) * this.fps.video); // fps * ms
            //console.log([playingFrame, curFrame]);
            for (let timing of timings) {
              timing.filter((i)=>playingId.includes(i[3].id)&&i[1]<curFrame).forEach(async (i)=>{
                console.log("end  :", playingFrame+" - "+curFrame, i);
                await i[2].end(i[3]);
                playingId.slice(playingId.findIndex((id)=>id==i[3].id), 1);
              });
              timing.filter((i)=>i[0]<=curFrame&&curFrame<i[1]).forEach(async (i)=>{
                if (!playingId.includes(i[3].id)) {
                  console.log("start  :", playingFrame+" - "+curFrame, i);
                  await i[2].start(i[3], curFrame-i[0]);
                  playingId.push(i[3].id);
                }
                i[3].options.forEach((option)=>Object.keys(option.__option).forEach((key)=>{if(OptionValue.prototype.isPrototypeOf(option.__option[key])){option.__option[key].time = (curFrame-i[0])/(i[1]-i[0]);option[key]=option.__option[key];}}));
              });
            }
            if (this.playing) {
              document.querySelector(".layers > input[name=\"time\"]").value = curFrame;
            }
            if (curFrame > lastFrame || !this.playing) {
              if (this.playing) {
                document.querySelector(".layers > input[name=\"time\"]").value = Math.min(lastFrame+1, curFrame);
              }
              try {
                clearInterval(interval);
              } catch {}
              for (let timing of timings) {
                await Promise.all(timing.filter((i)=>i[0]<=curFrame&&i[1]>=curFrame).map((i)=>i[2].pause(i[3])));
              }
              this.playing = false;
              this.dispatchEvent(new Event("play-stop"));
              return;
            }
            prevFrame = playingFrame;
            playingFrame = curFrame;
          }, 10);
          startTime = Date.now() - (playingFrame / this.fps.video);
        }

        async stopPreview() {
          this.playing = false;
        }

        async saveProject() {
          if (this.demo) {
            await Prompts.showError("この機能はデモ版では利用できません");
            return;
          }
          if (!this.dir) {
            this.dir = await showDirectoryPicker({mode:"readwrite"});
          }
          if (!await Prompts.askOk("プロジェクトを保存します。上書きされる可能性ありです。\n\n本 当 に よ ろ し い で す か ？")) {
            await Prompts.showError("ちぇっ");
            return;
          }
          let data = {
            version: VERSION,
            name: "",
            fps: this.fps,
            size: this.size,
            layers: this.layers.filter((layer=>layer.length>0)).map((layer)=>{
              return layer.map((src)=>{
                let srcData = {};
                if (File.prototype.isPrototypeOf(src.file)) {
                  srcData.path = src.path;
                }
                srcData.type = src.type;
                srcData.options = src.options.map((option)=>option.__option);
                return srcData;
              });
            })
          };
          let fileHandle = await this.dir.getFileHandle("meta.json");
          let writable = await fileHandle.createWritable();
          await writable.write(JSON.stringify(data, (key, value)=>{
            if (OptionValue.prototype.isPrototypeOf(value)) {
              return {begin:value.begin, end:value.end, type:value.type, as:"OptionValue"};
            } else {
              return value;
            }
          }));
          await writable.close();
          await Prompts.showInfo("保存が完了しました。");
        }

        async loadProject() {
          let fileHandle;
          if (!this.demo) {
            this.dir = await showDirectoryPicker({mode:"readwrite"});
            try {
              fileHandle = await this.dir.getFileHandle("meta.json", {create:true});
            } catch {
              await Prompts.showError("meta.jsonが見つかりませんでした。veditで作成されたプロジェクトディレクトリを選択してくさだい。")
              return;
            }
          } else {
            this.dir = new URL("demo/", location.href);
          }
          let popup = document.querySelector("pop-up#loading");
          let progress = document.createElement("progress");
          progress.style.width = "50vw";
          progress.style.minWidth = "100%";
          popup.body.insertAdjacentElement("afterbegin", progress);
          popup.body.insertAdjacentHTML("afterbegin",
            '<svg viewBox="0 0 256 256" width="256px" height="256px" xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com"><defs></defs><path style="fill: rgb(0, 106, 255);" d="M 120 0 C 120 66.274 66.274 120 0 120 C -66.274 120 -120 66.274 -120 0 C -120 -21.861 -114.154 -42.357 -103.94 -60.01 L -83.152 -48.008 C -91.323 -33.886 -96 -17.489 -96 0 C -96 53.019 -53.019 96 0 96 C 53.019 96 96 53.019 96 0 C 96 -53.019 53.019 -96 0 -96 L 0 -120 C 66.274 -120 120 -66.274 120 0 Z" transform="translate(128, 128)"><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" additive="sum" type="rotate" from="0" to="360"></animateTransform></path><path style="fill: rgb(0, 187, 255);" d="M 0.007 80 C -14.567 80 -28.231 76.103 -40 69.294 L -31.998 55.435 C -22.584 60.882 -11.652 64 0.007 64 C 35.353 64 64.007 35.346 64.007 0 L 80.007 0 C 80.007 44.183 44.19 80 0.007 80 Z" bx:origin="0.333372 0" transform="translate(128, 128)"><animateTransform attributeName="transform" dur="1.25s" repeatCount="indefinite" additive="sum" type="rotate" from="360" to="0"></animateTransform></path><path d="M 48.001 0 C 48.001 26.51 26.511 48 0.001 48 C -26.51 48 -48 26.51 -48 0 C -48 -17.765 -38.349 -33.276 -24.004 -41.576 L -8.001 -13.859 C -12.783 -11.092 -16 -5.922 -16 0 C -16 8.837 -8.837 16 0.001 16 C 8.838 16 16.001 8.837 16.001 0 C 16.001 -7.405 10.972 -13.634 4.143 -15.459 L 12.427 -46.376 C 32.914 -40.901 48.001 -22.213 48.001 0 Z" style="fill: rgb(0, 140, 255);" transform="translate(128, 128)" bx:origin="0.500001 0.491407"><animateTransform attributeName="transform" dur="2s" repeatCount="indefinite" additive="sum" type="rotate" from="0" to="360"></animateTransform></path></svg>'
          );
          let svg = popup.body.children[0];
          popup.activate();
          try {
            let data;
            try {
              if (!this.demo) {
                data = JSON.parse(await (await fileHandle.getFile()).text(), (key, value)=>{
                  if (Object.isPrototypeOf(value) && value.as == "OptionValue") {
                    return new OptionValue(value);
                  } else {
                    return value;
                  }
                });
              } else {
                let req = new XMLHttpRequest();
                let promise = new Promise((resolve, reject)=>{
                  req.addEventListener("readystatechange", ()=>{
                    if (req.readyState == 4) {
                      resolve(req.response);
                    }
                  });
                  req.addEventListener("error", reject);
                  req.addEventListener("abort", reject);
                });
                req.open("GET", new URL("meta.json", this.dir));
                req.overrideMimeType("application/json");
                req.setRequestHeader("Pragma", "no-cache");
                req.setRequestHeader("Cache-Control", "no-cache");
                req.setRequestHeader("If-Modified-Since", "Thu, 01 Jun 1970 00:00:00 GMT");
                req.send();
                data = JSON.parse(await promise, (key, value)=>{
                  if (Object.isPrototypeOf(value) && value.as == "OptionValue") {
                    return new OptionValue(value);
                  } else {
                    return value;
                  }
                });
              }
            } catch {
              if (!this.demo) {
                throw "meta.jsonが破損しているか、veditのものではありません。";
              } else {
                throw "何らかの問題が発生し、meta.jsonを読み込めませんでした。";
              }
            }
            console.log(data);
            if (data.version != VERSION) {
              throw "バージョンが違うため読み込めません。残念だったな。";
            }
            this.fps = data.fps;
            this.size = data.size;
            for (let layer = this.layers.length-1; layer >= 0; layer--) {
              for (let index = this.layers[layer].length-1; index >= 0; index--) {
                let src = this.layers[layer][index];
                this.removeSrcAt(layer, index);
                src.delete();
              }
            }
            console.log(this.layers);
            let layerIndex = 0;
            let handles = [];
            let size = 0;
            for (let layer of data.layers) {
              handles.push([]);
              for (let index = 0; index < layer.length; index++) {
                if (!this.demo) {
                  let dir = this.dir;
                  let fileHandle;
                  if (layer[index].path) {
                    let parsedPath = layer[index].path.match(/(?:(?:\\\/)|[^\/])+/g);
                    for (let name of parsedPath.slice(0, -1)) {
                      dir = await dir.getDirectoryHandle(name);
                    }
                    fileHandle = await dir.getFileHandle(parsedPath.at(-1));
                    let material = await this.getMaterial(fileHandle);
                  }
                  let cls = this.tree.getSourceClassFromType(layer[index].type) || SourceBase;
                  let file;
                  if (fileHandle) {
                    file = await fileHandle.getFile();
                    size += file.size;
                  }
                  handles.at(-1).push([cls, fileHandle, file?file.size:0]);
                } else {
                  let buffer, mime;
                  if (layer[index].path) {
                    let req = new XMLHttpRequest();
                    let promise = new Promise((resolve, reject)=>{
                      req.addEventListener("readystatechange", ()=>{
                        if (req.readyState == 4) {
                          resolve(req.response);
                        }
                      });
                      req.addEventListener("error", reject);
                      req.addEventListener("abort", reject);
                    });
                    req.responseType = "arraybuffer";
                    req.open("GET", new URL(layer[index].path, this.dir));
                    req.setRequestHeader("Pragma", "no-cache");
                    req.setRequestHeader("Cache-Control", "no-cache");
                    req.setRequestHeader("If-Modified-Since", "Thu, 01 Jun 1970 00:00:00 GMT");
                    req.send();
                    buffer = await promise;
                    console.log(req, buffer);
                    mime = req.getResponseHeader("Content-Type");
                    if (mime == null) {
                      mime = undefined;
                    }
                  }
                  let cls = this.tree.getSourceClassFromType(layer[index].type) || SourceBase;
                  if (buffer) {
                    size += buffer.byteLength || 0;
                  }
                  handles.at(-1).push([cls, [buffer, mime], buffer?buffer.byteLength||0:0]);
                }
              }
              layerIndex += 1;
            }
            progress.max = size;
            progress.min = 0;
            progress.value = 0;
            layerIndex = 0;
            for (let layer of data.layers) {
              for (let index = 0; index < layer.length; index++) {
                let src;
                let [cls, fileHandle, fileSize] = handles[layerIndex][index];
                if (layer[index].type != SOURCE_TYPES.TEXT) {
                  if (!this.demo) {
                    src = await cls.getSourceFromFileHandle(fileHandle);
                  } else {
                    // fileHandle is arrayBuffer;
                    let [arrayBuffer, mime] = fileHandle;
                    let format;
                    let fakeFile = {
                      text: ((buf)=>(()=>new Promise((resolve, reject)=>{
                        try {
                          resolve(String.fromCharCode(...new Uint8Array(buf)));
                        } catch {
                          reject();
                        }
                      })))(arrayBuffer),
                      arrayBuffer: ((buf)=>(async ()=>buf))(arrayBuffer),
                      type: mime,
                      name: layer[index].path?layer[index].path.split("/").at(-1):"unnamed"
                    };
                    if (layer[index].path) {
                      format = layer[index].path.match(/(?:(?<=\.)[a-zA-Z0-9]*)?$/)[0].toLowerCase();
                    }
                    if (cls == VideoSource) {
                      console.log(fileHandle);
                      if (!format) {
                        src = new cls(fakeFile, layer[index].path, arrayBuffer);
                      } else {
                        src = new cls(fakeFile, layer[index].path, arrayBuffer, format);
                      }
                    } else if (cls == AudioSource) {
                      let ctx = new AudioContext();
                      let audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                      if (!format) {
                        src = new cls(fakeFile, layer[index].path, audioBuffer);
                      } else {
                        src = new cls(fakeFile, layer[index].path, audioBuffer, format);
                      }
                    } else if (cls == ImageSource) {
                      src = new cls(fakeFile, layer[index].path, format);
                    } else {
                      throw "デモ版では使えないはずの素材が読み込まれようとしたため失敗しました。";
                    }
                  }
                } else {
                  src = new cls("");
                }
                let optionIndex = 0;
                for (let option of layer[index].options) {
                  if (src.options.length < optionIndex+1) {
                    continue;
                  }
                  try {
                    src.options[optionIndex].span = option.span;
                  } catch {}
                  for (let key of Object.keys(option)) {
                    if (["span", "timeScale"].includes(key)) {continue;}
                    try {
                      if (option.as == "OptionValue" || OptionValue.prototype.isPrototypeOf(src.options[optionIndex][key])) {
                        src.options[optionIndex][key] = new OptionValue(option[key]);
                      } else {
                        src.options[optionIndex][key] = option[key];
                      }
                    } catch {}
                  }
                  optionIndex += 1;
                }
                this.pushSrcAt(layerIndex, index, src);
                document.querySelector("li-layer[index=\""+layerIndex+"\"]").appendChild(src.sourceElement);
                progress.value += fileSize;
              }
              layerIndex += 1;
            }
            let lastFrame = Math.max(0, ...this.layers.map((layer)=>Math.max(0, ...layer.map((src)=>src.options.at(-1).frames[1]))));
            this.timeScale = this.timelineWidth / (this.timeScale * lastFrame);
            this.changeTimeScale(1);
            this.handleTimelineScroll();
            this.handleTimelineWidth();
            this.handleSeek();
          } catch(e) {
            await Prompts.showError(e);
            console.error(e);
          }
          progress.remove();
          svg.remove();
          popup.close();
        }

        async createProject() {
          if (this.demo) {
            await Prompts.showError("この機能はデモ版では利用できません");
            return;
          }
          this.dir = await showDirectoryPicker({mode:"readwrite"});
          if (!await Prompts.askOk("続行すると、"+this.dir.name+"に\n含まれるすべてのファイルがveditによって覗けたりいじったり出来るようになります。あと「meta.json」があれば上書きされます。\n\n本 当 に よ ろ し い で す ね ？ (^^)")) {
            await Prompts.showError("ﾌｰﾝ...(・|");
            return;
          }
          let fileHandle = await this.dir.getFileHandle("meta.json", {create:true});
          let data = {
            version: VERSION,
            name: "",
            fps: this.fps,
            size: this.size,
            layers: []
          };
          let writable = await fileHandle.createWritable();
          await writable.write(JSON.stringify(data, (key, value)=>{
            if (OptionValue.prototype.isPrototypeOf(value)) {
              return {begin:value.begin, end:value.end, type:value.type, as:"OptionValue"};
            } else {
              return value;
            }
          }));
          await writable.close()
          await Prompts.showInfo("たぶん作ったぞ");
        }

        async encode(file, options={}) {
          if (this.dir == undefined) {
            await Prompts.showError("先に新規プロジェクトを作成またはプロジェクトを読み込んでね。");
            return;
          }
          if (this.demo) {
            file = {
              array: new Uint8Array(),
              get buffer() {
                console.log(this);
                return this.array.buffer;
              },
              createWritable: async function() {
                return {
                  write: (chunk) => {
                    return new Promise((resolve, reject) => {
                      this.array = new Uint8Array([...this.array, ...chunk]);
                      resolve();
                    });
                  },
                  close: () => {},
                  abort(err) {
                    console.error(err);
                  }
                };
              }
            };
            console.log(file);
          }
          let popup = document.querySelector("pop-up#encoding");
          let progress = popup.querySelector("progress");
          progress.removeAttribute("max");
          popup.querySelectorAll("svg g.src").forEach((g)=>{
            g.setAttribute("class", "src");
            g.style.display = "none";
          });
          popup.querySelector("svg animateTransform[name=\"hook-anime\"]").parentNode.style.display = "none";
          popup.activate();
          this.encoderOptions = {
            format:options.format || "mp4",
            codecs: {
              audio: (options.codecs || {}).audio || "aac",
              video: (options.codecs || {}).video || "avc1"
            }
          };
          this.videoEncoderMetadata = {};
          this.audioEncoderMetadata = {};
          this.ms = Math.max(...this.layers.map((layer)=>Math.max(...layer.map((src)=>src.options.at(-1).frames[1])))) / this.fps.video;
          if (this.demo) {
            if (this.ms > 10000) {
              await Prompts.Error("デモ版のため、動画の長さを10秒に切り詰めます。");
            }
            this.ms = Math.min(10000, this.ms);
          }
          this.generatedVideoFrames = [];
          this.encodedVideoChunks = [];
          this.encodedAudioChunks = [];
          this.videoEncoder = new VideoEncoder({
            output: (chunk, metadata)=>this.handleEncodedVideoChunk(chunk, metadata),
            error: console.error
          });
          this.videoEncoder.configure({
            codec:"avc1.42C029", //this.encoderOptions.codecs.video,
            width: this.size.width,
            height: this.size.height,
            bitrateMode: "quantizer",
            framerate: this.fps.video,
            hardwareAcceleration: "prefer-hardware"
          });
          this.audioEncoder = new AudioEncoder({
            output: (chunk, metadata)=>this.handleEncodedAudioChunk(chunk, metadata),
            error: console.error
          });
          let audioconfig = await AudioEncoder.isConfigSupported({
            codec:"mp4a.40.2",
            sampleRate: this.sampleRate,
            numberOfChannels: this.isStereo?2:1,
            aac:{format:"aac"}
          });
          console.log(audioconfig);
          if (audioconfig.supported) {
            this.audioEncoder.configure(audioconfig.config);
          } else {
            this.encoderOptions.codecs.audio = undefined;
          }
          let audioCtx = new OfflineAudioContext({
            numberOfChannels: this.isStereo?2:1,
            length: Math.ceil(this.sampleRate * this.ms / 1000),
            sampleRate: this.sampleRate
          });
          let workspace = document.createElement("svg");
          let promises = [];
          for (let layer of this.layers) {
            for (let src of layer) {
              if (src.hasAudio()) {
                promises.push(src.decodeReady(audioCtx));
              } else {
                promises.push(src.decodeReady());
              }
            }
          }
          await Promise.all(promises);
          // handle audio first, process in background
          console.log(promises);
          let timings = [];
          let handlingSources = new Map();
          for (let layer of this.layers) {
            let timing = [];
            for (let src of layer) {
              timing.push([...src.options[0].frames, src]);
              if (src.hasAudio()) {
                let node = await src.getAudioNode();
                node.connect(audioCtx.destination);
                if (AudioBufferSourceNode.prototype.isPrototypeOf(node)) {
                  node.start(src.options[0].frames[0] / (this.fps.video * 1000), src.options[0].span[0] / (this.fps.video * 1000), (src.options[0].frames[1] - src.options[0].frames[0]) / (this.fps.video * 1000));
                } else if (AudioScheduledSourceNode.prototype.isPrototypeOf(node)) {
                  node.start(src.options[0].frames[0] / (this.fps.video * 1000));
                  node.stop(src.options[0].frames[1] / (this.fps.video * 1000));
                } else {
                  console.warn("unsupported AudioNode instance:", node);
                }
              }
            }
            timings.push(timing);
          }
          let audioPromise = audioCtx.startRendering();
          console.log("start audio encoding in background");
          console.log("start video encoding");
          console.log(timings);
          // animation start
          popup.querySelector("svg animateTransform[name=\"hook-anime\"]").addEventListener("repeatEvent", ()=>{
            popup.querySelectorAll("svg g.src").forEach((g)=>{
              g.style.display = "";
            });
            popup.querySelector("svg animateTransform[name=\"hook-anime\"]").parentNode.style.display = "";
          }, {once: true});
          
          popup.querySelector("svg animateTransform[name=\"hook-anime\"]").onrepeat = ()=>{
            if (this.ms >= curFrame * 1000 / this.fps.video) {
              let srctypes = ((array)=>[...array.map((src)=>src.type), ...Array(Math.max(0,4-array.length)).fill(-1)].sort(()=>Math.random()-0.5).slice(0,4))([...handlingSources.values()]);
              popup.querySelectorAll("svg g.src").forEach((g)=>{
                let srctype = srctypes.pop();
                if (srctype == SOURCE_TYPES.VIDEO) {
                  g.setAttribute("class", "src video");
                } else if (srctype == SOURCE_TYPES.AUDIO) {
                  g.setAttribute("class", "src audio");
                } else if (srctype == SOURCE_TYPES.IMAGE) {
                  g.setAttribute("class", "src image");
                } else if (srctype == SOURCE_TYPES.TEXT) {
                  g.setAttribute("class", "src text");
                } else if (srctype == SOURCE_TYPES.SHAPE) {
                  g.setAttribute("class", "src shape");
                } else if (srctype == SOURCE_TYPES.EFFECT) {
                  g.setAttribute("class", "src effect");
                } else if (srctype == SOURCE_TYPES.UNKNOWN) {
                  g.setAttribute("class", "src unknown");
                } else {
                  g.setAttribute("class", "src");
                }
              });
            }
          }
          progress.value = 0;
          progress.setAttribute("max", this.ms);
          let curFrame = 0;
          while (this.ms >= curFrame * 1000 / this.fps.video) {
            progress.value = curFrame * 1000 / this.fps.video;
            await new Promise((resolve, reject)=>{setTimeout(resolve, 0)}); // to make time for other tasks to process
            let monitor = new Uint32Array(this.size.width * this.size.height);
            for (let timing of timings) {
              timing.filter((i)=>(curFrame-1)*1000<i[0]&&i[0]<=curFrame*1000).forEach((i)=>{
                console.log("start:", curFrame, i);
                handlingSources.set(i[2].id, i[2]);
              });
              timing.filter((i)=>(curFrame-1)*1000<i[1]&&i[1]<=curFrame*1000).forEach((i)=>{
                console.log("end  :", curFrame, i);
                handlingSources.delete(i[2].id);
              });
            }
            for (let src of handlingSources.values()) {
              src.options.forEach((option)=>Object.keys(option.__option).forEach((key)=>{if(OptionValue.prototype.isPrototypeOf(option.__option[key])){option.__option[key].time = (curFrame * 1000 - src.options[0].frames[0])/(src.options[0].frames[1]-src.options[0].frames[0]);option[key]=option.__option[key];}}))
              let data = await src.getFrame(curFrame - Math.round(src.options[0].frames[0] / 1000));
              //console.log(data);
              if (data == undefined) {
                continue;
              }
              if (VideoFrame.prototype.isPrototypeOf(data)) {
                if (data.codedWidth == 0 || data.codedHeight == 0) {
                  data.close();
                  continue;
                }
                let rect = {
                  width: src.options[0].width.curValue,
                };
                let temp;
                let [Y, U, V] = [];
                switch (data.format) {
                  case "RGBA":
                  case "RGBX":
                    temp = new Uint32Array(data.displayWidth * data.displayHeight);
                    await data.copyTo(temp);
                    break;
                  case "BGRA":
                  case "BGRX":
                    temp = new Uint32Array(data.displayWidth * data.displayHeight);
                    await data.copyTo(temp);
                    temp.forEach((value, index, array)=>{
                      array[index] = ((0xff000000 & value) | ((value & 0xff0000) >>> 16)
                        | (0xff00 & value)
                        | ((0xff & value) << 16)) >>> 0;
                    });
                    break;
                  case "I420":
                    temp = new Uint8Array(data.allocationSize());
                    [Y, U, V] = await data.copyTo(temp);
                    console.log([Y,U,V]);
                    //console.time("i420");
                    temp = Uint32Array.from(temp.slice(Y.offset, Y.offset+Y.stride*data.displayHeight), (value, index, array)=>{
                      let [y, cb, cr] = [Math.min(Math.max(0, (value-16)/219), 1), (temp[U.offset+Math.floor(index/(Y.stride*2))*U.stride+Math.floor((index%Y.stride)/2)] - 128) / 255, (temp[V.offset+Math.floor(index/(Y.stride*2))*V.stride+Math.floor((index%Y.stride)/2)] - 128) / 255];
                      return (0xff000000 | (Math.min(Math.max(0, (y + cb * 1.772) * 255) >>> 0, 255) << 16)
                        | (Math.min(Math.max(0, (y + cb * (-0.34414) + cr * (-0.71414)) * 255) >>> 0, 255) << 8)
                        | (Math.min(Math.max(0, (y + cr * 1.402) * 255) >>> 0, 255))) >>> 0;
                    });
                    //console.timeEnd("i420");
                    break;
                  case "I444":
                    temp = new Uint8Array(data.allocationSize());
                    [Y, U, V] = await data.copyTo(temp);
                    console.log([Y,U,V], 1);
                    //console.time("i420");
                    temp = Uint32Array.from(temp.slice(Y.offset, Y.offset+Y.stride*data.displayHeight), (value, index, array)=>{
                      let [y, cb, cr] = [Math.min(Math.max(0, (value-16)/219), 1), (temp[U.offset+Math.floor(index/(Y.stride*2))*U.stride+Math.floor((index%Y.stride)/2)] - 128) / 255, (temp[V.offset+Math.floor(index/(Y.stride*2))*V.stride+Math.floor((index%Y.stride)/2)] - 128) / 255];
                      return (0xff000000 | (Math.min(Math.max(0, (y + cb * 1.772) * 255) >>> 0, 255) << 16)
                        | (Math.min(Math.max(0, (y + cb * (-0.34414) + cr * (-0.71414)) * 255) >>> 0, 255) << 8)
                        | (Math.min(Math.max(0, (y + cr * 1.402) * 255) >>> 0, 255))) >>> 0;
                    });
                    break;
                  case "I420A":
                    temp = new Uint8Array(data.allocationSize());
                    Y, U, V = await data.copyTo(temp)
                    temp.forEach((value, index, array)=>{
                      array[index] = ((0xff000000 & value) | (((0xff0000 & value) + (0xff & value) * 1.13983) >>> 0)
                        | (((0xff0000 & value) + (0xff00 & value) * (-0.39465) + (0xff & value) * (-0.58060)) >>> 0)
                        | (((0xff0000 & value) + (0xff00 & value) * 2.03211) >>> 0)) >>> 0;
                    });
                    break;
                  default:
                    data.close();
                    continue;
                  
                }
                //console.time("scale");
                let displayWidth = Math.round(src.options[0].width.curValue);
                let displayHeight = Math.round(src.options[0].height.curValue);
                let scaleWidth = displayWidth / data.displayWidth;
                let scaleHeight = displayHeight / data.displayHeight;
                if (scaleWidth  != 1 || scaleHeight != 1) {
                  temp = new Uint32Array([...(function*(w,h,oldW,oldH){
                    for(let y=0; y < h; y++) {
                      for(let x=0; x < w; x++) {
                        let srcX = Math.floor(x / scaleWidth);
                        let srcY = Math.floor(y / scaleHeight);
                        let deltaX = x / scaleWidth - srcX;
                        let deltaY = y / scaleHeight - srcY;
                        if (deltaX == 0 && deltaY == 0) {
                          yield temp[Math.round((y*oldW / scaleHeight)+(x / scaleWidth))];
                          continue;
                        } else {
                          var red = 0;
                          var green = 0;
                          var blue = 0;
                          var alpha = 0;
                          let v
                          if (srcX-deltaX > -1 && srcY-deltaY > -1 && srcX-deltaX < w && srcY-deltaY < h) {
                            let percentage = (1 - deltaX) * (1 - deltaY);
                            let value = temp[srcX + srcY * oldW];
                            red += (value & 0xff) * percentage;
                            green += ((value & 0xff00) >>> 8) * percentage;
                            blue += ((value & 0xff0000) >>> 16) * percentage;
                            alpha += ((value & 0xff000000) >>> 24) * percentage;
                          } else {
                            alpha += 63.25;
                          }
                          if (srcX-deltaX+1 > -1 && srcY-deltaY > -1 && srcX-deltaX+1 < w && srcY-deltaY < h) {
                            let percentage = deltaX * (1 - deltaY);
                            let value = temp[srcX+1 + srcY * oldW];
                            red += (value & 0xff) * percentage;
                            green += ((value & 0xff00) >>> 8) * percentage;
                            blue += ((value & 0xff0000) >>> 16) * percentage;
                            alpha += ((value & 0xff000000) >>> 24) * percentage;
                          } else {
                            alpha += 63.25;
                          }
                          if (srcX-deltaX > -1 && srcY-deltaY+1 > -1 && srcX-deltaX < w && srcY-deltaY+1 < h) {
                            let percentage = (1 - deltaX) * deltaY;
                            let value = temp[srcX + (srcY+1) * oldW];
                            red += (value & 0xff) * percentage;
                            green += ((value & 0xff00) >>> 8) * percentage;
                            blue += ((value & 0xff0000) >>> 16) * percentage;
                            alpha += ((value & 0xff000000) >>> 24) * percentage;
                          } else {
                            alpha += 63.25;
                          }
                          if (srcX-deltaX+1 > -1 && srcY-deltaY+1 > -1 && srcX-deltaX+1 < w && srcY-deltaY+1 < h) {
                            let percentage = deltaX * deltaY;
                            let value = temp[srcX+1 + (srcY+1) * oldW];
                            red += (value & 0xff) * percentage;
                            green += ((value & 0xff00) >>> 8) * percentage;
                            blue += ((value & 0xff0000) >>> 16) * percentage;
                            alpha += ((value & 0xff000000) >>> 24) * percentage;
                          } else {
                            alpha += 63.25;
                          }
                          yield ((Math.min(Math.max(0, Math.round(alpha)), 255) << 24)
                        | (Math.min(Math.max(0, Math.round(blue)), 255) << 16)
                        | (Math.min(Math.max(0, Math.round(green)), 255) << 8)
                        | Math.min(Math.max(0, Math.round(red)), 255)) >>> 0;
                        }
                      }
                    }
                  })(displayWidth,displayHeight, data.displayWidth, data.displayHeight)]);
                }
                data.close();
                //console.timeEnd("scale");
                //console.time("rotate");
                let cosA = Math.cos((src.options[0].rotate.curValue || 0) * 2 * Math.PI / 360);
                let sinA = Math.sin((src.options[0].rotate.curValue || 0) * 2 * Math.PI / 360);
                let xs = [0, displayWidth * cosA - displayHeight * sinA, displayWidth * cosA,  -1*displayHeight * sinA];
                let ys = [0, displayWidth * sinA + displayHeight * cosA, displayWidth * sinA, displayHeight * cosA];
                let offsetX = Math.min(...xs);
                let offsetY = Math.min(...ys);
                let w = Math.round(Math.max(...xs)-offsetX);
                let h = Math.round(Math.max(...ys)-offsetY);
                var temp2;
                if ((src.options[0].rotate.curValue || 0) === 0 && 0) {
                  temp2 = temp;
                } else {
                  temp2 = new Uint32Array(w * h);
                  for (let y=0; y < h; y++) {
                    for (let x=0; x < w; x++) {
                      let X = (x + offsetX) * cosA + (y + offsetY) * sinA;
                      let Y = -1 * (x + offsetX) * sinA + (y + offsetY) * cosA;
                      if (X <= -1 || Y <= -1 || X >= displayWidth || Y >= displayHeight) {
                        continue;
                      }
                      let intX = Math.floor(X);
                      let intY = Math.floor(Y);
                      let deltaX = X - intX;
                      let deltaY = Y - intY;
                      var red = 0;
                      var green = 0;
                      var blue = 0;
                      var alpha = 0;
                      if (X-deltaX > -1 && Y-deltaY > -1 && X-deltaX < displayWidth && Y-deltaY < displayHeight) {
                        let percentage = (1 - deltaX) * (1 - deltaY);
                        let value = temp[intX + intY * displayWidth];
                        red += (value & 0xff) * percentage;
                        green += ((value & 0xff00) >>> 8) * percentage;
                        blue += ((value & 0xff0000) >>> 16) * percentage;
                        alpha += ((value & 0xff000000) >>> 24) * percentage;
                      }
                      if (X-deltaX+1 > -1 && Y-deltaY > -1 && X-deltaX+1 < displayWidth && Y-deltaY < displayHeight) {
                        let percentage = deltaX * (1 - deltaY);
                        let value = temp[intX+1 + intY * displayWidth];
                        red += (value & 0xff) * percentage;
                        green += ((value & 0xff00) >>> 8) * percentage;
                        blue += ((value & 0xff0000) >>> 16) * percentage;
                        alpha += ((value & 0xff000000) >>> 24) * percentage;
                      }
                      if (X-deltaX > -1 && Y-deltaY+1 > -1 && X-deltaX < displayWidth && Y-deltaY+1 < displayHeight) {
                        let percentage = (1 - deltaX) * deltaY;
                        let value = temp[intX + (intY+1) * displayWidth];
                        red += (value & 0xff) * percentage;
                        green += ((value & 0xff00) >>> 8) * percentage;
                        blue += ((value & 0xff0000) >>> 16) * percentage;
                        alpha += ((value & 0xff000000) >>> 24) * percentage;
                      }
                      if (X-deltaX+1 > -1 && Y-deltaY+1 > -1 && X-deltaX+1 < displayWidth && Y-deltaY+1 < displayHeight) {
                        let percentage = deltaX * deltaY;
                        let value = temp[intX+1 + (intY+1) * displayWidth];
                        red += (value & 0xff) * percentage;
                        green += ((value & 0xff00) >>> 8) * percentage;
                        blue += ((value & 0xff0000) >>> 16) * percentage;
                        alpha += ((value & 0xff000000) >>> 24) * percentage;
                      }
                      temp2[x + y * w] = ((Math.min(Math.max(0, Math.round(alpha)), 255) << 24)
                        | (Math.min(Math.max(0, Math.round(blue)), 255) << 16)
                        | (Math.min(Math.max(0, Math.round(green)), 255) << 8)
                        | Math.min(Math.max(0, Math.round(red)), 255)) >>> 0;
                    }
                  }
                }
                //console.timeEnd("rotate");
                //console.time("paste");
                // ABGR(BGRA) -> ARGB(RGBA)
                if (src.options[0].posOriginRoot == "top-left") {
                  offsetX += src.options[0].x.curValue;
                  offsetY += src.options[0].y.curValue;
                } else if (src.options[0].posOriginRoot == "center") {
                  offsetX += src.options[0].x.curValue + this.size.width / 2;
                  offsetY += src.options[0].y.curValue + this.size.height / 2;
                }
                if (src.options[0].posOrigin == "top-left") {
                  // do nothing
                } else if (src.options[0].posOrigin == "center") {
                  offsetX -= (src.options[0].width.curValue * cosA - src.options[0].height.curValue * sinA) / 2;
                  offsetY -= (src.options[0].width.curValue * sinA + src.options[0].height.curValue * cosA) / 2;
                }
                for (let y=0; y < h; y++) {
                  for (let x=0; x < w; x++) {
                    let value = temp2[x+y*w];
                    if (value & 0xff000000 == 0) {continue;}
                    let X = Math.round(x + offsetX);
                    let Y = Math.round(y + offsetY);
                    if (0 <= X && X <= this.size.width - 1 && 0 <= Y && y <= this.size.height - 1) {
                      let distIndex = X+Y*this.size.width;
                      let dist = monitor[distIndex];
                      let alpha = ((value & 0xff000000) >>> 24) * (1 - src.options[0].alpha.curValue) / 0xff;
                      monitor[distIndex] = ((Math.round((dist & 0xff) * (1 - alpha) + (value & 0xff) * alpha) & 0xff) +
                        (Math.round((dist & 0xff00) * (1 - alpha) + (value & 0xff00) * alpha) & 0xff00) +
                        (Math.round((dist & 0xff0000) * (1 - alpha) + (value & 0xff0000) * alpha) & 0xff0000) | 0xff000000) >>> 0;
                    }
                  }
                }
                //console.timeEnd("paste");
              }
            }
            let result = new VideoFrame(monitor, {format:"RGBA", codedWidth:this.size.width, codedHeight:this.size.height, colorSpace:new VideoColorSpace(), timestamp:(curFrame/this.fps.video)*1000});
            try {
              this.videoEncoder.encode(result);
            } catch(e) {
              console.error(e);
            }
            this.generatedVideoFrames.push(result);
            curFrame += 1;
          }

          this.videoEncoder.flush().then(()=>{
            try {
              this.videoEncoder.close();
            } catch {}
            while (this.generatedVideoFrames.length > 0) {
              this.generatedVideoFrames.pop().close();
            }
            console.log("video encode finished.");
            audioPromise.then((audioBuffer)=>{
              var totalBuffer = new Float32Array(audioBuffer.length * audioBuffer.numberOfChannels);
              for (let ch=0; ch < audioBuffer.numberOfChannels; ch++) {
                let buffer = audioBuffer.getChannelData(ch);
                console.log(buffer);
                totalBuffer.set(buffer, audioBuffer.length * ch);
              }
              let audioData = new AudioData({
                format: "f32-planar",
                sampleRate: audioBuffer.sampleRate,
                numberOfFrames: audioBuffer.length,
                numberOfChannels: audioBuffer.numberOfChannels,
                data: totalBuffer,
                timestamp: 0
              });
              if (this.encoderOptions.codecs.audio) {
                this.audioEncoder.encode(audioData);
              }
              this.audioEncoder.flush().finally(()=>{
                try {
                  this.audioEncoder.close();
                } catch {}
                console.log("audio encode finished.");
                popup.querySelector("svg animateTransform[name=\"hook-anime\"]").addEventListener("repeatEvent", ()=>{
                  popup.querySelectorAll("svg g.src").forEach((g)=>{
                    g.style.display = "none";
                  });
                  popup.querySelector("svg animateTransform[name=\"hook-anime\"]").parentNode.style.display = "none";
                  popup.querySelector("svg animateTransform[name=\"hook-anime\"]").onrepeat = undefined;
                }, {once: true});
                this.generateOutputVideo(file).catch(console.error);
              }).catch((e)=>{
                if (this.encoderOptions.codecs.audio) {
                  Prompts.showError(e.toString());
                  console.error(e);
                }
              });
            }).catch((e)=>{Prompts.showError(e.toString());console.error(e);});
          }).catch((e)=>{Prompts.showError(e.toString());console.error(e);});
        }

        handleEncodedVideoChunk(chunk, metadata) {
          this.encodedVideoChunks.push(chunk);
          console.log("metadata: ", metadata);
          this.videoEncoderMetadata = {...this.videoEncoderMetadata, ...metadata};
        }

        handleEncodedAudioChunk(chunk, metadata) {
          this.encodedAudioChunks.push(chunk);
          console.log("metadata: ", metadata);
          this.audioEncoderMetadata = {...this.audioEncoderMetadata, ...metadata};
        }

        async generateOutputVideo(file) {
          var outputVideoFile = file;
          var outputBoxes = [];
          let creationTime = convertIntToArray(Math.floor((new Date() - new Date("1904-01-01 00:00:00")) / 1000), 4);
          let modificationTime = [...creationTime];
          let duration = convertIntToArray(Math.ceil(this.ms*this.fps.video), 4);
          if (true) {
            outputBoxes.push(new MP4Box("ftyp"));
            outputBoxes.push(new MP4Box("moov"));
            outputBoxes.push(new MP4Box("mdat"));

            outputBoxes[0].child = new Uint8Array([..."isom\0\0\0\0mp41avc1"].map((ch)=>ch.charCodeAt(0)));

            /*  moov
                mvhd
                trak
                tkhd
                mdia
                mdhd
                hdlr
                minf
                vmhd
                dinf
                dref
                url 
                stbl
                stsd
                avc1
                avcC
                stts
                stsc
                stsz
                stco
                stss
                mdat */

            outputBoxes[1].child = [
              new MP4Box("mvhd"),
            ];


            outputBoxes[1].child[0].child  = new Uint8Array(100);
            outputBoxes[1].child[0].child.set([0], 0);
            outputBoxes[1].child[0].child.set([0, 0, 0], 1);
            outputBoxes[1].child[0].child.set(creationTime, 4);
            outputBoxes[1].child[0].child.set(modificationTime, 8);
            outputBoxes[1].child[0].child.set(convertIntToArray(this.fps.video*1000, 4), 12);
            outputBoxes[1].child[0].child.set(convertIntToArray(Math.ceil(this.ms*this.fps.video), 4), 16);
            outputBoxes[1].child[0].child.set([0, 1, 0, 0], 20);
            outputBoxes[1].child[0].child.set([1, 0], 24);
            outputBoxes[1].child[0].child.set([
              [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
              [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0],
              [0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0]
            ].flat(), 26); //matrix, 36 bytes, 16.16 fixed float
            outputBoxes[1].child[0].child.set([0, 0, 0, 0], 62);
            outputBoxes[1].child[0].child.copyWithin(66, 16, 20);
            outputBoxes[1].child[0].child.set([0, 0, 0, 0], 70);
            outputBoxes[1].child[0].child.set([0, 0, 0, 0], 74);
            outputBoxes[1].child[0].child.copyWithin(78, 16, 20);
            outputBoxes[1].child[0].child.set([0, 0, 0, 0], 82);
            outputBoxes[1].child[0].child.set([0, 0, 0, 0], 86); //next track id
            // 謎の 10 bytes が余った...

            let tracks = [];
            if (this.encoderOptions.codecs.video) {
              tracks.push({type: "video"});
            }
            if (this.encoderOptions.codecs.audio) {
              tracks.push({type: "audio"});
            }

            var trackId = 0;
            var layerId = [0, 0];
            for (let track of tracks) {
              trackId += 1;
              let tr = new MP4Box("trak");
              let trackTimeScale = convertIntToArray((track.type=="video")?(this.fps.video*1000):this.sampleRate, 4);
              outputBoxes[1].child.push(tr);
              tr.child = [
                new MP4Box("tkhd"),
                new MP4Box("mdia")
              ];
              tr.child[0].child = new Uint8Array(84);
              tr.child[0].child.set([0], 0);
              tr.child[0].child.set([0, 0, 1], 1);
              tr.child[0].child.set(creationTime, 4);
              tr.child[0].child.set(modificationTime, 8);
              tr.child[0].child.set(convertIntToArray(trackId, 4), 12);
              // 4 bytes reserved
              tr.child[0].child.set(duration, 20);
              // 8 bytes reserved
              tr.child[0].child.set(layerId, 32);
              tr.child[0].child.set([0, 0], 34);
              tr.child[0].child.set([1, 0], 36);
              // 2 bytes reserved
              tr.child[0].child.set([
                [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
                [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0],
                [0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0]
              ].flat(), 40)// 36 bytes Matrix structure
              tr.child[0].child.set(convertIntToArray(this.size.width, 4), 76);
              tr.child[0].child.set(convertIntToArray(this.size.height, 4), 80);

              tr.child[1].child = [
                new MP4Box("mdhd"),
                new MP4Box("hdlr"),
                new MP4Box("minf")
              ];

              tr.child[1].child[0].child = new Uint8Array(24);
              tr.child[1].child[0].child.set(tr.child[0].child.slice(0, 12));
              tr.child[1].child[0].child.set(trackTimeScale, 12);
              tr.child[1].child[0].child.set(duration, 16);
              tr.child[1].child[0].child.set([0, 0], 20); // 0: English, 10: Japanese
              tr.child[1].child[0].child.set([0, 0], 22); // playback quality???

              let componentName = track.type=="video"?"vedit VideoHandler":"vedit AudioHandler";
              tr.child[1].child[1].child = new Uint8Array(24+componentName.length+1);
              tr.child[1].child[1].child.set([0], 0);
              tr.child[1].child[1].child.set([0, 0, 0], 1);
              tr.child[1].child[1].child.set([...[..."mhlr"].map((ch)=>ch.charCodeAt(0))], 4);
              tr.child[1].child[1].child.set([...(track.type=="video"?"vide":"soun")].map((ch)=>ch.charCodeAt(0)), 8);
              tr.child[1].child[1].child.set([0, 0, 0, 0], 12);
              tr.child[1].child[1].child.set([0, 0, 0, 0], 16);
              tr.child[1].child[1].child.set([0, 0, 0, 0], 20);
              tr.child[1].child[1].child.set([...[...componentName].map((ch)=>ch.charCodeAt(0)), 0], 24);

              tr.child[1].child[2].child = [
                new MP4Box(track.type=="video"?"vmhd":"smhd"),
                new MP4Box("dinf"),
                new MP4Box("stbl")
              ];

              tr.child[1].child[2].child[0].child = new Uint8Array(12);
              tr.child[1].child[2].child[0].child.set([0], 0);
              tr.child[1].child[2].child[0].child.set([0, 0, 0], 1);
              tr.child[1].child[2].child[0].child.set([0, 0], 4);
              tr.child[1].child[2].child[0].child.set([0, 0, 0, 0, 0, 0], 6);
              
              tr.child[1].child[2].child[1].child = [new MP4Box("dref", true)];
              tr.child[1].child[2].child[1].child[0].child = [new Uint8Array(8), new MP4Box("url ")];
              tr.child[1].child[2].child[1].child[0].child[0].set([0, 0, 0, 1], 4);
              tr.child[1].child[2].child[1].child[0].child[1].child = new Uint8Array(4);
              // 手抜き。ぜんぶ0だから。

              let stbl = tr.child[1].child[2].child[2];

              stbl.child = [
                new MP4Box("stsd", true),
                new MP4Box("stts"),
                new MP4Box("stsc"),
                new MP4Box("stco"),
                new MP4Box("stsz"),
              ];

              if (track.type == "video") {
                // video
                stbl.child.push(new MP4Box("stss"));
                stbl.child[0].child = [
                  new Uint8Array(8),
                  new MP4Box("avc1", true),
                ];

                stbl.child[0].child[0].set([0], 0);
                stbl.child[0].child[0].set([0, 0, 0], 1);
                stbl.child[0].child[0].set([0, 0, 0, 1], 4);
                
                stbl.child[0].child[1].child = [
                  new Uint8Array(78),
                  new MP4Box("avcC")
                ];

                // 6 bytes reserved
                stbl.child[0].child[1].child[0].set([0, 1], 6);
                stbl.child[0].child[1].child[0].set([0, 0], 8);
                stbl.child[0].child[1].child[0].set([0, 0], 10);
                stbl.child[0].child[1].child[0].set([0, 0, 0, 0], 12);
                stbl.child[0].child[1].child[0].set([0, 0, 0, 0], 16);
                stbl.child[0].child[1].child[0].set([0, 0, 0, 0], 20);
                stbl.child[0].child[1].child[0].set(convertIntToArray(this.size.width, 2), 24);
                stbl.child[0].child[1].child[0].set(convertIntToArray(this.size.height, 2), 26);
                stbl.child[0].child[1].child[0].set([0, 72, 0, 0], 28); // 72dpi
                stbl.child[0].child[1].child[0].set([0, 72, 0, 0], 32); // 72dpi
                stbl.child[0].child[1].child[0].set([0, 0, 0, 0], 36);
                stbl.child[0].child[1].child[0].set([0, 1], 40);
                // 32 bytes of Compressor name (skip)
                stbl.child[0].child[1].child[0].set([0, 24], 74);
                stbl.child[0].child[1].child[0].set([255, 255], 76); // 0xffff -> -0x0001
                
                /*let avcDecoderConfigurationRecord = new AVCDecoderConfigurationRecord(
                  {}
                );*/

                if (this.videoEncoderMetadata.decoderConfig != undefined && this.videoEncoderMetadata.decoderConfig.description != undefined) {
                  stbl.child[0].child[1].child[1].child = new Uint8Array(this.videoEncoderMetadata.decoderConfig.description);
                } else {
                  throw "No description";
                }

                if (this.videoEncoderMetadata.decoderConfig != undefined && this.videoEncoderMetadata.decoderConfig.colorSpace != undefined) {
                  let colr = new MP4Box("colr");
                  stbl.child[0].child[1].child.push(colr);

                  colr.child = new Uint8Array(10);
                  colr.child.set([..."nclc"].map((ch)=>ch.charCodeAt(0)), 0);

                  if (this.videoEncoderMetadata.decoderConfig.colorSpace.primaries == "bt709") {
                    colr.child.set([0, 1], 4);
                  } else if (this.videoEncoderMetadata.decoderConfig.colorSpace.primaries == "bt470bg") {
                    colr.child.set([0, 5], 4);
                  } else if (this.videoEncoderMetadata.decoderConfig.colorSpace.primaries == "smpte170m") {
                    colr.child.set([0, 6], 4);
                  }

                  if (this.videoEncoderMetadata.decoderConfig.colorSpace.transfer == "bt709") {
                    colr.child.set([0, 1], 6);
                  } else if (this.videoEncoderMetadata.decoderConfig.colorSpace.transfer == "smpte170m") {
                    colr.child.set([0, 6], 6);
                  } else if (this.videoEncoderMetadata.decoderConfig.colorSpace.transfer == "iec61966-2-1") {
                    colr.child.set([0, 13], 6);
                  }

                  if (this.videoEncoderMetadata.decoderConfig.colorSpace.matrix == "rgb") {
                    colr.child.set([0, 1], 8);
                  } else if (this.videoEncoderMetadata.decoderConfig.colorSpace.matrix == "bt709") {
                    colr.child.set([0, 1], 8);
                  } else if (this.videoEncoderMetadata.decoderConfig.colorSpace.matrix == "bt470bg") {
                    colr.child.set([0, 5], 8);
                  } else if (this.videoEncoderMetadata.decoderConfig.colorSpace.matrix == "smpte170m") {
                    colr.child.set([0, 6], 8);
                  }
                }

                stbl.child[1].child = new Uint8Array(16);
                stbl.child[1].child.set([0], 0);
                stbl.child[1].child.set([0, 0, 0], 1);
                stbl.child[1].child.set([0, 0, 0, 1], 4);
                stbl.child[1].child.set([...convertIntToArray(this.encodedVideoChunks.length, 4), ...convertIntToArray(1000, 4)], 8);

                let stsc_entries = [];
                var stsc_chunkIndex = 0;
                for (let i = 0; i < this.encodedVideoChunks.length; i++) {
                  if (this.encodedVideoChunks[i].type == "delta") {
                    stsc_entries.at(-1)[1]++;
                  } else {
                    stsc_chunkIndex++;
                    if (stsc_entries.length > 1 && stsc_entries.at(-1)[1] == stsc_entries.at(-2)[1]) {
                      stsc_entries.at(-1)[0] = stsc_chunkIndex;
                      stsc_entries.at(-1)[1] = 1;
                    } else {
                      stsc_entries.push([stsc_chunkIndex, 1, 1])
                    }
                  }
                }
                if (stsc_entries.length > 1 && stsc_entries.at(-1)[1] == stsc_entries.at(-2)[1]) {
                  stsc_entries.pop();
                }
                
                stbl.child[2].child = new Uint8Array(8 + 12*stsc_entries.length);
                stbl.child[2].child.set([0], 0);
                stbl.child[2].child.set([0, 0, 0], 1);
                stbl.child[2].child.set(convertIntToArray(stsc_entries.length, 4), 4);
                stbl.child[2].child.set(stsc_entries.flat().map((i)=>convertIntToArray(i, 4)).flat(), 8);

                track.chunkSize = this.encodedVideoChunks.filter((chunk)=>chunk.type=="key").length;

                track.stco = stbl.child[3];
                stbl.child[3].child = new Uint8Array(8 + track.chunkSize*8);
                stbl.child[3].child.set([0], 0);
                stbl.child[3].child.set([0, 0, 0], 1);
                stbl.child[3].child.set(convertIntToArray(track.chunkSize, 4), 4);
                // 実際のオフセットはまだ確定できないからスキップ

                stbl.child[4].child = new Uint8Array(12 + this.encodedVideoChunks.length * 4);
                stbl.child[4].child.set([0], 0);
                stbl.child[4].child.set([0, 0, 0], 1);
                stbl.child[4].child.set(convertIntToArray(this.encodedVideoChunks.length, 4), 8);
                for (let i=0; i < this.encodedVideoChunks.length; i++) {
                  stbl.child[4].child.set(convertIntToArray(this.encodedVideoChunks[i].byteLength, 4), 12+i*4);
                }

                let keyChunks = [];
                this.encodedVideoChunks.forEach((chunk, index)=>{
                  if (chunk.type == "key") {
                    keyChunks.push(index+1);
                  }
                });
                stbl.child[5].child = new Uint8Array(8 + keyChunks.length * 4);
                stbl.child[5].child.set([0], 0);
                stbl.child[5].child.set([0, 0, 0], 1);
                stbl.child[5].child.set(convertIntToArray(keyChunks.length, 4), 4);
                for (let i=0; i < keyChunks.length; i++) {
                  stbl.child[5].child.set(convertIntToArray(keyChunks[i], 4), 8+4*i);
                }
              } else {
                // audio
                stbl.child[0].child = [
                  new Uint8Array(8),
                  new MP4Box("mp4a", true)
                ];

                stbl.child[0].child[0].set([0], 0);
                stbl.child[0].child[0].set([0, 0, 0], 1);
                stbl.child[0].child[0].set([0, 0, 0, 1], 4);
                
                stbl.child[0].child[1].child = [
                  new Uint8Array(28),
                  new MP4Box("esds")
                ];

                // 6 bytes reserved
                stbl.child[0].child[1].child[0].set([0, 1], 6);
                stbl.child[0].child[1].child[0].set([0, 0], 8);
                stbl.child[0].child[1].child[0].set([0, 0], 10);
                stbl.child[0].child[1].child[0].set([0, 0, 0, 0], 12);
                stbl.child[0].child[1].child[0].set([0, this.isStereo?2:1], 16);
                stbl.child[0].child[1].child[0].set([0, 16], 18);
                stbl.child[0].child[1].child[0].set([255, 254], 20);
                stbl.child[0].child[1].child[0].set([0, 0], 22);
                stbl.child[0].child[1].child[0].set([...convertIntToArray(this.sampleRate, 2), 0, 0], 24);
                
                /*if (this.audioEncoderMetadata.decoderConfig != undefined && this.audioEncoderMetadata.decoderConfig.description != undefined) {
                  stbl.child[0].child[1].child[1].child = new Uint8Array([0, 0, 0, 0, ...new Uint8Array(this.audioEncoderMetadata.decoderConfig.description)]);
                } else {
                  throw "No description";
                }*/

                stbl.child[0].child[1].child[1].child = new Uint8Array([
                  0, 0, 0, 0, // version, flags
                  // ESDescriptor
                  0x03, // ES_DescrTag 
                  0x80, 0x80, 0x80, 0x22, // size (34bytes)
                  ...convertIntToArray(trackId, 2), // ES_ID
                  0, // flags
                  ...[ // DecoderConfigDescriptor decConfigDescr;
                    0x04, // DecoderConfigDescrTag
                    0x80, 0x80, 0x80, 0x14, // size (20bytes)
                    0x40, // objectTypeIndication, MPEG-4 AAC LC
                    0x15, // streamType[6bit] = 5 | upstream[1bit] = 0 | reserved[1bit] = 1; (0x15=0b00010101)
                    0, 0, 0, // bufferSizeDB[24bit]
                    ...convertIntToArray(69000, 4), // maxBitrate :thinking: ...
                    ...convertIntToArray(58223, 4), // avgBitrate :thinking: ...
                    ...[ // DecoderSpecificInfo decSpecificInfo;
                      0x05, // DecSpecificInfoTag
                      0x80, 0x80, 0x80, this.audioEncoderMetadata.decoderConfig.description.byteLength, // size
                      /*(2 << 3) // audioObjectType, AAC LC: 2
                      | (0x03 >>> 1), ((0x03 << 7) & 0x80) // sampling FrequencyIndex, 48000Hz: 3
                      | (this.isStereo?2:1) << 3 // channelConfiguration, 5チャンネル以下はチャンネル数そのまま
                      | 0 // GASpecificConfig[3bit]*/
                      ...new Uint8Array(this.audioEncoderMetadata.decoderConfig.description)
                    ],
                  ],
                  ...[ // SLConfigDescriptor sl_config;
                    0x06, // SLConfigDescrTag
                    0x80, 0x80, 0x80, 0x01, // size
                    0x02 // predefined
                  ]
                ]);

                stbl.child[1].child = new Uint8Array(16);
                stbl.child[1].child.set([0], 0);
                stbl.child[1].child.set([0, 0, 0], 1);
                stbl.child[1].child.set([0, 0, 0, 1], 4);
                stbl.child[1].child.set([...convertIntToArray(this.encodedAudioChunks.length, 4), ...convertIntToArray(1000, 4)], 8);

                let stsc_entries = [];
                var stsc_chunkIndex = 0;
                for (let i = 0; i < this.encodedAudioChunks.length; i++) {
                  if (this.encodedAudioChunks[i].type == "delta") {
                    stsc_entries.at(-1)[1]++;
                  } else {
                    stsc_chunkIndex++;
                    if (stsc_entries.length > 1 && stsc_entries.at(-1)[1] == stsc_entries.at(-2)[1]) {
                      stsc_entries.at(-1)[0] = stsc_chunkIndex;
                      stsc_entries.at(-1)[1] = 1;
                    } else {
                      stsc_entries.push([stsc_chunkIndex, 1, 1])
                    }
                  }
                }
                if (stsc_entries.length > 1 && stsc_entries.at(-1)[1] == stsc_entries.at(-2)[1]) {
                  stsc_entries.pop();
                }
                console.log(stsc_entries);
                
                stbl.child[2].child = new Uint8Array(8 + 12*stsc_entries.length);
                stbl.child[2].child.set([0], 0);
                stbl.child[2].child.set([0, 0, 0], 1);
                stbl.child[2].child.set(convertIntToArray(stsc_entries.length, 4), 4);
                stbl.child[2].child.set(stsc_entries.flat().map((i)=>convertIntToArray(i, 4)).flat(), 8);

                track.chunkSize = this.encodedAudioChunks.filter((chunk)=>chunk.type=="key").length;

                track.stco = stbl.child[3];
                stbl.child[3].child = new Uint8Array(8 + track.chunkSize*8);
                stbl.child[3].child.set([0], 0);
                stbl.child[3].child.set([0, 0, 0], 1);
                stbl.child[3].child.set(convertIntToArray(track.chunkSize, 4), 4);
                // 実際のオフセットはまだ確定できないからスキップ

                stbl.child[4].child = new Uint8Array(12 + this.encodedAudioChunks.length * 4);
                stbl.child[4].child.set([0], 0);
                stbl.child[4].child.set([0, 0, 0], 1);
                stbl.child[4].child.set(convertIntToArray(this.encodedAudioChunks.length, 4), 8);
                for (let i=0; i < this.encodedAudioChunks.length; i++) {
                  stbl.child[4].child.set(convertIntToArray(this.encodedAudioChunks[i].byteLength, 4), 12+i*4);
                }
              }
            }

            let metaOffset = outputBoxes.reduce((total, box)=>total+box.getLength(), 0n);
            let totalChunkSize = this.encodedVideoChunks.reduce((total, chunk)=>total+BigInt(chunk.byteLength), 0n)
              + this.encodedAudioChunks.reduce((total, chunk)=>total+BigInt(chunk.byteLength), 0n);
            console.log(totalChunkSize);
            if (totalChunkSize > 0xffffffffn) {
              metaOffset += 8n;
            }
            if (metaOffset + totalChunkSize > 0xffffffffn) {
              // stco -> co64
              tracks.forEach((track)=>{
                track.stco.type = "co64";
                track.stco.child = new Uint8Array(8 + track.chunkSize*12);
                track.stco.child.set([0], 0);
                track.stco.child.set([0, 0, 0], 1);
                track.stco.child.set(convertIntToArray(track.chunkSize, 4), 4);
              });
              var chunkOffset = metaOffset + 16n;
              tracks.forEach((track)=>{
                if (track.type == "video") {
                  var k=0;
                  for (let i=0; i < this.encodedVideoChunks.length; i++) {
                    if (this.encodedVideoChunks[i].type == "key") {
                      track.stco.child.set(convertBigIntToArray(chunkOffset, 8), 8 + k * 12);
                      track.stco.child.set(convertIntToArray(k+1, 4), 16 + k * 12);
                      k += 1;
                    }
                    chunkOffset += BigInt(this.encodedVideoChunks[i].byteLength);
                  }
                } else if (track.type == "audio") {
                  var k=0;
                  for (let i=0; i < this.encodedAudioChunks.length; i++) {
                    if (this.encodedAudioChunks[i].type == "key") {
                      track.stco.child.set(convertBigIntToArray(chunkOffset, 8), 8 + k * 12);
                      track.stco.child.set(convertIntToArray(k+1, 4), 16 + k * 12);
                      k += 1;
                    }
                    chunkOffset += BigInt(this.encodedAudioChunks[i].byteLength);
                  }
                }
              });
            } else {
              var chunkOffset = metaOffset;
              tracks.forEach((track)=>{
                if (track.type == "video") {
                  var k=0;
                  for (let i=0; i < this.encodedVideoChunks.length; i++) {
                    if (this.encodedVideoChunks[i].type == "key") {
                      console.log("chunkOffset", chunkOffset);
                      track.stco.child.set(convertBigIntToArray(chunkOffset, 4), 8 + k * 4);
                      k += 1;
                    }
                    chunkOffset += BigInt(this.encodedVideoChunks[i].byteLength);
                  }
                } else if (track.type == "audio") {
                  var k=0;
                  for (let i=0; i < this.encodedAudioChunks.length; i++) {
                    if (this.encodedAudioChunks[i].type == "key") {
                      console.log("chunkOffset", chunkOffset);
                      track.stco.child.set(convertBigIntToArray(chunkOffset, 4), 8 + k * 4);
                      k += 1;
                    }
                    chunkOffset += BigInt(this.encodedAudioChunks[i].byteLength);
                  }
                }
              });

              outputBoxes.pop(2);

              let metaBinaries = outputBoxes.map((box)=>box.getBinary());

              let fileStream = await outputVideoFile.createWritable();
              for (let binary of metaBinaries) {
                await fileStream.write(binary);
              }

              var dataHeader;
              if (totalChunkSize > 0xffffffffn) {
                dataHeader = new Uint8Array([0, 0, 0, 1, ...[..."mdat"].map((ch)=>ch.charCodeAt(0)), ...convertBigIntToArray(totalChunkSize + 16n, 8)]);
              } else {
                dataHeader = new Uint8Array([...convertBigIntToArray(totalChunkSize + 8n, 4), ...[..."mdat"].map((ch)=>ch.charCodeAt(0))]);
              }

              await fileStream.write(dataHeader);

              for (let chunk of this.encodedVideoChunks) {
                let buffer = new Uint8Array(chunk.byteLength);
                chunk.copyTo(buffer);
                await fileStream.write(buffer);
                try {
                  chunk.close();
                } catch {
                  ;
                }
              }

              for (let chunk of this.encodedAudioChunks) {
                let buffer = new Uint8Array(chunk.byteLength);
                chunk.copyTo(buffer);
                await fileStream.write(buffer);
                try {
                  chunk.close();
                } catch {
                  ;
                }
              }

              try{
                await fileStream.close();
              } catch (e) {
                console.error(e);
              }
            }
          }

          //console.log("nothing...");
          await Prompts.showInfo("動画のエンコードが完了しました。");

          if (this.demo) {
            let blob = new Blob([outputVideoFile.buffer], {type:"video/mp4"});
            let url = URL.createObjectURL(blob);
            let video = document.createElement("video");
            //video.preload = "none";
            video.style.width = "60vw";
            video.style.margin = "1em";
            video.setAttribute("controls", "");
            video.src = url;
            //setTvideo.load();
            await Prompts.showInfo(video);
            URL.revokeObjectURL(url);
          }

          try {
            outputVideoFile.close();
          } catch {}

          await this.cleanAfterEncode();
          try {
            document.querySelector("pop-up#encoding").close();
          } catch {}
        }
        async cleanAfterEncode() {
          while (this.encodedVideoChunks.length > 0) {
            this.encodedVideoChunks.pop();
          }
          while (this.encodedAudioChunks.length > 0) {
            this.encodedAudioChunks.pop();
          }
        }
      }
      var main;
      window.addEventListener("DOMContentLoaded", ()=>{
        main = new EditorMain();
        [[VideoSource, SOURCE_TYPES.VIDEO],
        [AudioSource, SOURCE_TYPES.AUDIO],
        [ImageSource, SOURCE_TYPES.IMAGE],
        [TextSource, SOURCE_TYPES.TEXT]].forEach((i)=>{
          let callback = i[0].check;
          main.tree.register(i[0], callback, i[1]);
        });
      });
    </script>
  </body>
</html>